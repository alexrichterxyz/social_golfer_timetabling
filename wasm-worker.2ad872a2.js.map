{"mappings":"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A,gBACA,iBACA,mBACA,0BACA,oBACA,iBACA,qBACA,cACA,iBACA,iBACA,SACA,SACA,SACA,eACA,qBACA,mBACA,gBACA,kBACA,sBACA,qBACA,2BACA,yBACA,kBACA,wBACA,qBACA,6BACA,6BACA,0BACA,6BACA,iCACA,yCACA,4BACA,oCACA,oBACA,iCACA,yCACA,gCACA,wCACA,6BACA,qCACA,0BACA,mCACA,wBACA,eACA,wCACA,sBACA,iCACA,yCACA,wCACA,qBACA,gCACA,wCACA,6BACA,uBACA,+BACA,oCACA,uBACA,UACA,+BACA,uBACA,uBACA,eACA,eACA,4BACA,gBACA,iBACA,yBACA,yBACA,iBACA,aACA,iBACA,sBACA,4BACA,wBACA,uBACA,sBACA,aACA,cACA,gBACA,sBACA,oBACA,kCACA,aACA,eACA,WACA,UACA,kBACA,mBACA,yBACA,uBACA,aACA,mBACA,eACA,sBACA,yBACA,oBACA,sCACA,uCACA,kCACA,gCACA,wCACA,gCACA,kCACA,qBACA,gCACA,iCACA,iCACA,4BACA,0BACA,6CACA,uBACA,iCACA,+BACA,eACA,6BACA,qBACA,eACA,cACA,WACA,sBACA,qBACA,WACA,aACA,sBACA,2BACA,mBACA,4BACA,8BACA,4BACA,4BACA,2BACA,mBACA,eACA,sBACA,oBACA,mBACA,oBACA,oBACA,wBACD,CACqB,OAAO,CA/uF7B,SAA8B,CAAG,EAqB/B,EAAwB,EAC1B,GAygGA,AA9S0B,CACxB,MACA,mBACA,sBACA,MACA,MACA,WACA,QACA,aACA,cACA,UACA,UACA,QACA,SACA,SACA,UACA,SACA,UACA,SACA,UACA,mBACA,mBACA,YACA,YACA,qBACA,YACA,eACA,cACA,0BACA,MACA,cACA,MACA,YACA,UACA,SACA,WACA,qBACA,YACA,gBACA,cACA,eACA,mBACA,sBACA,WACA,WACA,OACA,UACA,cACA,oBACA,eACA,oBACA,eACA,kBACA,gBACA,eACA,gBACA,gBACA,mBACA,gBACA,gBACA,mBACA,WACA,qBACA,wBACA,4BACA,0BACA,eACA,aACA,sBACA,iBACA,wBACA,mBACA,aACA,yBACA,gBACA,kBACA,gBACA,UACA,oBACA,oBACA,gBACA,eACA,gBACA,8BACA,OACA,qBACA,kBACA,gCACA,6BACA,WACA,iBACA,0BACA,YACA,gBACA,kBACA,cACA,KACA,UACA,YACA,aACA,aACA,eACA,eACA,iBACA,iBACA,uBACA,iBACA,oBACA,eACA,gBACA,aACA,cACA,iBACA,oBACA,gBACA,gBACA,iBACA,YACA,kBACA,YACA,WACA,YACA,cACA,cACA,YACA,cACA,6BACA,qBACA,eACA,eACA,eACA,aACA,mBACA,YACA,sBACA,eACA,kBACA,iBACA,eACA,eACA,uBACA,WACA,WACA,aACA,oBACA,eACA,eACA,YACA,WACA,aACA,YACA,WACA,YACA,kBACA,gBACA,YACA,WACA,WACA,aACA,YACA,WACA,aACA,cACA,UACA,WACA,WACA,aACA,WACA,YACA,YACA,aACA,WACA,YACA,YACA,gBACA,cACA,eACA,WACA,UACA,WACA,cACA,YACA,UACA,WACA,UACA,WACA,WACA,eACA,SACA,WACA,8BACA,0BACA,8BACA,2BACA,gBACA,UACA,UACA,gBACA,iBACA,gBACA,oBACA,mBACA,oBACA,kBACA,kBACA,gBACA,cACA,eACA,qBACA,QACA,MACA,SACA,SACA,uBACA,4BACA,0BACA,KACA,KACA,OACA,MACA,OACA,WACA,MACA,UACA,eACA,sBACA,QACA,WACA,UACA,gBACA,eACA,qBACA,oBACA,kBACA,uBACA,mBACA,qBACA,sBACA,qBACA,gCACA,cACA,kBACA,sBACA,wBACA,sBACA,gBACA,sBACA,kBACA,mBACA,sBACA,YACA,oBACA,wBACA,sBACA,qBACA,sBACA,sBACA,aACA,sBACA,mBACA,uBACA,qBACA,eACA,8BACA,4BACA,qBACA,cACA,iBACA,uBACA,0BACA,2BACA,sCACA,yCACA,yBACA,oBACA,iCACA,gBACA,qBACA,uBACA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","sources":["<anon>","src/js/wasm-worker.js","public/optimizer.js"],"sourcesContent":["(() => {\n\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire2492\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire2492\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"lQc82\", function(module, exports) {\n\nvar $8iurf = parcelRequire(\"8iurf\");\nconst $fe67dcd16bfc3fb2$var$modulePromise = (0, (/*@__PURE__*/$parcel$interopDefault($8iurf)))();\nasync function $fe67dcd16bfc3fb2$var$optimize(config) {\n    const Module = await $fe67dcd16bfc3fb2$var$modulePromise;\n    const serialized = Module.optimize(config.groups, config.people.length, config.roles.length, config.tables, config.weeks);\n    const result = {\n        person: [],\n        group: [],\n        role: [],\n        table: [],\n        week: []\n    };\n    for(let week = 0; week < config.weeks; week++)for(let group = 0; group < config.groups; group++){\n        const offset = week * config.groups + group;\n        const person = config.people[serialized.get(offset)];\n        const roleRaw = serialized.get(offset + 1);\n        const role = roleRaw < config.roles.length ? config.roles[roleRaw] : '';\n        const table = serialized.get(offset + 2) + 1;\n        result.person.push(person);\n        result.week.push(week);\n        result.group.push(group);\n        result.role.push(role);\n        result.table.push(table);\n    }\n    self.postMessage({\n        operation: 'result',\n        payload: result\n    });\n}\nself.onmessage = async (e)=>{\n    self.postMessage({\n        operation: 'log',\n        payload: 'This is a test'\n    });\n    switch(e.data.operation){\n        case 'optimize':\n            $fe67dcd16bfc3fb2$var$optimize(e.data.payload);\n            break;\n        default:\n            break;\n    }\n};\n\n});\nparcelRegister(\"8iurf\", function(module, exports) {\nvar $60a79d9be2fe59af$var$createModule = (()=>{\n    var _scriptName = typeof document != 'undefined' ? document.currentScript?.src : undefined;\n    return async function(moduleArg = {}) {\n        var moduleRtn;\n        // include: shell.js\n        // The Module object: Our interface to the outside world. We import\n        // and export values on it. There are various ways Module can be used:\n        // 1. Not defined. We create it here\n        // 2. A function parameter, function(moduleArg) => Promise<Module>\n        // 3. pre-run appended it, var Module = {}; ..generated code..\n        // 4. External script tag defines var Module.\n        // We need to check if Module already exists (e.g. case 3 above).\n        // Substitution will be replaced with actual code on later stage of the build,\n        // this way Closure Compiler will not mangle it (e.g. case 4. above).\n        // Note that if you want to run closure, and also to use Module\n        // after the generated code, you will need to define   var Module = {};\n        // before the code. Then that object will be used in the code, and you\n        // can continue to use Module afterwards as well.\n        var Module = moduleArg;\n        // Determine the runtime environment we are in. You can customize this by\n        // setting the ENVIRONMENT setting at compile time (see settings.js).\n        var ENVIRONMENT_IS_WEB = true;\n        var ENVIRONMENT_IS_WORKER = false;\n        var ENVIRONMENT_IS_NODE = false;\n        var ENVIRONMENT_IS_SHELL = false;\n        // --pre-jses are emitted after the Module integration code, so that they can\n        // refer to Module (if they choose; they can also define Module)\n        var arguments_ = [];\n        var thisProgram = './this.program';\n        var quit_ = (status, toThrow)=>{\n            throw toThrow;\n        };\n        // `/` should be present at the end if `scriptDirectory` is not empty\n        var scriptDirectory = '';\n        function locateFile(path) {\n            if (Module['locateFile']) return Module['locateFile'](path, scriptDirectory);\n            return scriptDirectory + path;\n        }\n        // Hooks that are implemented differently in different runtime environments.\n        var readAsync, readBinary;\n        if (ENVIRONMENT_IS_SHELL) {\n            const isNode = false;\n            if (isNode || typeof window == 'object' || typeof WorkerGlobalScope != 'undefined') throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');\n        } else // Note that this includes Node.js workers when relevant (pthreads is enabled).\n        // Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and\n        // ENVIRONMENT_IS_NODE.\n        if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n            try {\n                scriptDirectory = new URL('.', _scriptName).href; // includes trailing slash\n            } catch  {\n            // Must be a `blob:` or `data:` URL (e.g. `blob:http://site.com/etc/etc`), we cannot\n            // infer anything from them.\n            }\n            if (!(typeof window == 'object' || typeof WorkerGlobalScope != 'undefined')) throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');\n            // include: web_or_worker_shell_read.js\n            readAsync = async (url)=>{\n                assert(!isFileURI(url), \"readAsync does not work with file:// URLs\");\n                var response = await fetch(url, {\n                    credentials: 'same-origin'\n                });\n                if (response.ok) return response.arrayBuffer();\n                throw new Error(response.status + ' : ' + response.url);\n            };\n        } else throw new Error('environment detection error');\n        var out = console.log.bind(console);\n        var err = console.error.bind(console);\n        var IDBFS = 'IDBFS is no longer included by default; build with -lidbfs.js';\n        var PROXYFS = 'PROXYFS is no longer included by default; build with -lproxyfs.js';\n        var WORKERFS = 'WORKERFS is no longer included by default; build with -lworkerfs.js';\n        var FETCHFS = 'FETCHFS is no longer included by default; build with -lfetchfs.js';\n        var ICASEFS = 'ICASEFS is no longer included by default; build with -licasefs.js';\n        var JSFILEFS = 'JSFILEFS is no longer included by default; build with -ljsfilefs.js';\n        var OPFS = 'OPFS is no longer included by default; build with -lopfs.js';\n        var NODEFS = 'NODEFS is no longer included by default; build with -lnodefs.js';\n        // perform assertions in shell.js after we set up out() and err(), as otherwise\n        // if an assertion fails it cannot print the message\n        assert(!ENVIRONMENT_IS_WORKER, 'worker environment detected but not enabled at build time.  Add `worker` to `-sENVIRONMENT` to enable.');\n        assert(!ENVIRONMENT_IS_NODE, 'node environment detected but not enabled at build time.  Add `node` to `-sENVIRONMENT` to enable.');\n        assert(!ENVIRONMENT_IS_SHELL, 'shell environment detected but not enabled at build time.  Add `shell` to `-sENVIRONMENT` to enable.');\n        // end include: shell.js\n        // include: preamble.js\n        // === Preamble library stuff ===\n        // Documentation for the public APIs defined in this file must be updated in:\n        //    site/source/docs/api_reference/preamble.js.rst\n        // A prebuilt local version of the documentation is available at:\n        //    site/build/text/docs/api_reference/preamble.js.txt\n        // You can also build docs locally as HTML or other formats in site/\n        // An online HTML version (which may be of a different version of Emscripten)\n        //    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html\n        var wasmBinary;\n        if (typeof WebAssembly != 'object') err('no native wasm support detected');\n        // Wasm globals\n        //========================================\n        // Runtime essentials\n        //========================================\n        // whether we are quitting the application. no code should run after this.\n        // set in exit() and abort()\n        var ABORT = false;\n        // set by exit() and abort().  Passed to 'onExit' handler.\n        // NOTE: This is also used as the process return code code in shell environments\n        // but only when noExitRuntime is false.\n        var EXITSTATUS;\n        // In STRICT mode, we only define assert() when ASSERTIONS is set.  i.e. we\n        // don't define it at all in release modes.  This matches the behaviour of\n        // MINIMAL_RUNTIME.\n        // TODO(sbc): Make this the default even without STRICT enabled.\n        /** @type {function(*, string=)} */ function assert(condition, text) {\n            if (!condition) abort('Assertion failed' + (text ? ': ' + text : ''));\n        }\n        // We used to include malloc/free by default in the past. Show a helpful error in\n        // builds with assertions.\n        /**\n * Indicates whether filename is delivered via file protocol (as opposed to http/https)\n * @noinline\n */ var isFileURI = (filename)=>filename.startsWith('file://');\n        // include: runtime_common.js\n        // include: runtime_stack_check.js\n        // Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode.\n        function writeStackCookie() {\n            var max = _emscripten_stack_get_end();\n            assert((max & 3) == 0);\n            // If the stack ends at address zero we write our cookies 4 bytes into the\n            // stack.  This prevents interference with SAFE_HEAP and ASAN which also\n            // monitor writes to address zero.\n            if (max == 0) max += 4;\n            // The stack grow downwards towards _emscripten_stack_get_end.\n            // We write cookies to the final two words in the stack and detect if they are\n            // ever overwritten.\n            HEAPU32[max >> 2] = 0x02135467;\n            HEAPU32[max + 4 >> 2] = 0x89BACDFE;\n            // Also test the global address 0 for integrity.\n            HEAPU32[0] = 1668509029;\n        }\n        function checkStackCookie() {\n            if (ABORT) return;\n            var max = _emscripten_stack_get_end();\n            // See writeStackCookie().\n            if (max == 0) max += 4;\n            var cookie1 = HEAPU32[max >> 2];\n            var cookie2 = HEAPU32[max + 4 >> 2];\n            if (cookie1 != 0x02135467 || cookie2 != 0x89BACDFE) abort(`Stack overflow! Stack cookie has been overwritten at ${ptrToString(max)}, expected hex dwords 0x89BACDFE and 0x2135467, but received ${ptrToString(cookie2)} ${ptrToString(cookie1)}`);\n            // Also test the global address 0 for integrity.\n            if (HEAPU32[0] != 0x63736d65 /* 'emsc' */ ) abort('Runtime error: The application has corrupted its heap memory area (address zero)!');\n        }\n        // end include: runtime_stack_check.js\n        // include: runtime_exceptions.js\n        // end include: runtime_exceptions.js\n        // include: runtime_debug.js\n        var runtimeDebug = true; // Switch to false at runtime to disable logging at the right times\n        // Used by XXXXX_DEBUG settings to output debug messages.\n        function dbg(...args) {\n            if (!runtimeDebug && typeof runtimeDebug != 'undefined') return;\n            // TODO(sbc): Make this configurable somehow.  Its not always convenient for\n            // logging to show up as warnings.\n            console.warn(...args);\n        }\n        // Endianness check\n        (()=>{\n            var h16 = new Int16Array(1);\n            var h8 = new Int8Array(h16.buffer);\n            h16[0] = 0x6373;\n            if (h8[0] !== 0x73 || h8[1] !== 0x63) throw 'Runtime error: expected the system to be little-endian! (Run with -sSUPPORT_BIG_ENDIAN to bypass)';\n        })();\n        function consumedModuleProp(prop) {\n            if (!Object.getOwnPropertyDescriptor(Module, prop)) Object.defineProperty(Module, prop, {\n                configurable: true,\n                set () {\n                    abort(`Attempt to set \\`Module.${prop}\\` after it has already been processed.  This can happen, for example, when code is injected via '--post-js' rather than '--pre-js'`);\n                }\n            });\n        }\n        function makeInvalidEarlyAccess(name) {\n            return ()=>assert(false, `call to '${name}' via reference taken before Wasm module initialization`);\n        }\n        function ignoredModuleProp(prop) {\n            if (Object.getOwnPropertyDescriptor(Module, prop)) abort(`\\`Module.${prop}\\` was supplied but \\`${prop}\\` not included in INCOMING_MODULE_JS_API`);\n        }\n        // forcing the filesystem exports a few things by default\n        function isExportedByForceFilesystem(name) {\n            return name === 'FS_createPath' || name === 'FS_createDataFile' || name === 'FS_createPreloadedFile' || name === 'FS_unlink' || name === 'addRunDependency' || // The old FS has some functionality that WasmFS lacks.\n            name === 'FS_createLazyFile' || name === 'FS_createDevice' || name === 'removeRunDependency';\n        }\n        /**\n * Intercept access to a global symbol.  This enables us to give informative\n * warnings/errors when folks attempt to use symbols they did not include in\n * their build, or no symbols that no longer exist.\n */ function hookGlobalSymbolAccess(sym, func) {\n        // In MODULARIZE mode the generated code runs inside a function scope and not\n        // the global scope, and JavaScript does not provide access to function scopes\n        // so we cannot dynamically modify the scrope using `defineProperty` in this\n        // case.\n        //\n        // In this mode we simply ignore requests for `hookGlobalSymbolAccess`. Since\n        // this is a debug-only feature, skipping it is not major issue.\n        }\n        function missingGlobal(sym, msg) {\n            hookGlobalSymbolAccess(sym, ()=>{\n                warnOnce(`\\`${sym}\\` is not longer defined by emscripten. ${msg}`);\n            });\n        }\n        missingGlobal('buffer', 'Please use HEAP8.buffer or wasmMemory.buffer');\n        missingGlobal('asm', 'Please use wasmExports instead');\n        function missingLibrarySymbol(sym) {\n            hookGlobalSymbolAccess(sym, ()=>{\n                // Can't `abort()` here because it would break code that does runtime\n                // checks.  e.g. `if (typeof SDL === 'undefined')`.\n                var msg = `\\`${sym}\\` is a library symbol and not included by default; add it to your library.js __deps or to DEFAULT_LIBRARY_FUNCS_TO_INCLUDE on the command line`;\n                // DEFAULT_LIBRARY_FUNCS_TO_INCLUDE requires the name as it appears in\n                // library.js, which means $name for a JS name with no prefix, or name\n                // for a JS name like _name.\n                var librarySymbol = sym;\n                if (!librarySymbol.startsWith('_')) librarySymbol = '$' + sym;\n                msg += ` (e.g. -sDEFAULT_LIBRARY_FUNCS_TO_INCLUDE='${librarySymbol}')`;\n                if (isExportedByForceFilesystem(sym)) msg += '. Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you';\n                warnOnce(msg);\n            });\n            // Any symbol that is not included from the JS library is also (by definition)\n            // not exported on the Module object.\n            unexportedRuntimeSymbol(sym);\n        }\n        function unexportedRuntimeSymbol(sym) {\n            if (!Object.getOwnPropertyDescriptor(Module, sym)) Object.defineProperty(Module, sym, {\n                configurable: true,\n                get () {\n                    var msg = `'${sym}' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the Emscripten FAQ)`;\n                    if (isExportedByForceFilesystem(sym)) msg += '. Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you';\n                    abort(msg);\n                }\n            });\n        }\n        // end include: runtime_debug.js\n        var readyPromiseResolve, readyPromiseReject;\n        // Memory management\n        var wasmMemory;\n        var /** @type {!Int8Array} */ HEAP8, /** @type {!Uint8Array} */ HEAPU8, /** @type {!Int16Array} */ HEAP16, /** @type {!Uint16Array} */ HEAPU16, /** @type {!Int32Array} */ HEAP32, /** @type {!Uint32Array} */ HEAPU32, /** @type {!Float32Array} */ HEAPF32, /** @type {!Float64Array} */ HEAPF64;\n        // BigInt64Array type is not correctly defined in closure\n        var /** not-@type {!BigInt64Array} */ HEAP64, /* BigUint64Array type is not correctly defined in closure\n/** not-@type {!BigUint64Array} */ HEAPU64;\n        var runtimeInitialized = false;\n        function updateMemoryViews() {\n            var b = wasmMemory.buffer;\n            HEAP8 = new Int8Array(b);\n            HEAP16 = new Int16Array(b);\n            HEAPU8 = new Uint8Array(b);\n            HEAPU16 = new Uint16Array(b);\n            HEAP32 = new Int32Array(b);\n            HEAPU32 = new Uint32Array(b);\n            HEAPF32 = new Float32Array(b);\n            HEAPF64 = new Float64Array(b);\n            HEAP64 = new BigInt64Array(b);\n            HEAPU64 = new BigUint64Array(b);\n        }\n        // include: memoryprofiler.js\n        // end include: memoryprofiler.js\n        // end include: runtime_common.js\n        assert(typeof Int32Array != 'undefined' && typeof Float64Array !== 'undefined' && Int32Array.prototype.subarray != undefined && Int32Array.prototype.set != undefined, 'JS engine does not provide full typed array support');\n        function preRun() {\n            if (Module['preRun']) {\n                if (typeof Module['preRun'] == 'function') Module['preRun'] = [\n                    Module['preRun']\n                ];\n                while(Module['preRun'].length)addOnPreRun(Module['preRun'].shift());\n            }\n            consumedModuleProp('preRun');\n            // Begin ATPRERUNS hooks\n            callRuntimeCallbacks(onPreRuns);\n        // End ATPRERUNS hooks\n        }\n        function initRuntime() {\n            assert(!runtimeInitialized);\n            runtimeInitialized = true;\n            checkStackCookie();\n            // No ATINITS hooks\n            wasmExports['__wasm_call_ctors']();\n        // No ATPOSTCTORS hooks\n        }\n        function postRun() {\n            checkStackCookie();\n            // PThreads reuse the runtime from the main thread.\n            if (Module['postRun']) {\n                if (typeof Module['postRun'] == 'function') Module['postRun'] = [\n                    Module['postRun']\n                ];\n                while(Module['postRun'].length)addOnPostRun(Module['postRun'].shift());\n            }\n            consumedModuleProp('postRun');\n            // Begin ATPOSTRUNS hooks\n            callRuntimeCallbacks(onPostRuns);\n        // End ATPOSTRUNS hooks\n        }\n        // A counter of dependencies for calling run(). If we need to\n        // do asynchronous work before running, increment this and\n        // decrement it. Incrementing must happen in a place like\n        // Module.preRun (used by emcc to add file preloading).\n        // Note that you can add dependencies in preRun, even though\n        // it happens right before run - run will be postponed until\n        // the dependencies are met.\n        var runDependencies = 0;\n        var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled\n        var runDependencyTracking = {};\n        var runDependencyWatcher = null;\n        function addRunDependency(id) {\n            runDependencies++;\n            Module['monitorRunDependencies']?.(runDependencies);\n            if (id) {\n                assert(!runDependencyTracking[id]);\n                runDependencyTracking[id] = 1;\n                if (runDependencyWatcher === null && typeof setInterval != 'undefined') // Check for missing dependencies every few seconds\n                runDependencyWatcher = setInterval(()=>{\n                    if (ABORT) {\n                        clearInterval(runDependencyWatcher);\n                        runDependencyWatcher = null;\n                        return;\n                    }\n                    var shown = false;\n                    for(var dep in runDependencyTracking){\n                        if (!shown) {\n                            shown = true;\n                            err('still waiting on run dependencies:');\n                        }\n                        err(`dependency: ${dep}`);\n                    }\n                    if (shown) err('(end of list)');\n                }, 10000);\n            } else err('warning: run dependency added without ID');\n        }\n        function removeRunDependency(id) {\n            runDependencies--;\n            Module['monitorRunDependencies']?.(runDependencies);\n            if (id) {\n                assert(runDependencyTracking[id]);\n                delete runDependencyTracking[id];\n            } else err('warning: run dependency removed without ID');\n            if (runDependencies == 0) {\n                if (runDependencyWatcher !== null) {\n                    clearInterval(runDependencyWatcher);\n                    runDependencyWatcher = null;\n                }\n                if (dependenciesFulfilled) {\n                    var callback = dependenciesFulfilled;\n                    dependenciesFulfilled = null;\n                    callback(); // can add another dependenciesFulfilled\n                }\n            }\n        }\n        /** @param {string|number=} what */ function abort(what) {\n            Module['onAbort']?.(what);\n            what = 'Aborted(' + what + ')';\n            // TODO(sbc): Should we remove printing and leave it up to whoever\n            // catches the exception?\n            err(what);\n            ABORT = true;\n            // Use a wasm runtime error, because a JS error might be seen as a foreign\n            // exception, which means we'd run destructors on it. We need the error to\n            // simply make the program stop.\n            // FIXME This approach does not work in Wasm EH because it currently does not assume\n            // all RuntimeErrors are from traps; it decides whether a RuntimeError is from\n            // a trap or not based on a hidden field within the object. So at the moment\n            // we don't have a way of throwing a wasm trap from JS. TODO Make a JS API that\n            // allows this in the wasm spec.\n            // Suppress closure compiler warning here. Closure compiler's builtin extern\n            // definition for WebAssembly.RuntimeError claims it takes no arguments even\n            // though it can.\n            // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure gets fixed.\n            /** @suppress {checkTypes} */ var e = new WebAssembly.RuntimeError(what);\n            readyPromiseReject?.(e);\n            // Throw the error whether or not MODULARIZE is set because abort is used\n            // in code paths apart from instantiation where an exception is expected\n            // to be thrown when abort is called.\n            throw e;\n        }\n        // show errors on likely calls to FS when it was not included\n        var FS = {\n            error () {\n                abort('Filesystem support (FS) was not included. The problem is that you are using files from JS, but files were not used from C/C++, so filesystem support was not auto-included. You can force-include filesystem support with -sFORCE_FILESYSTEM');\n            },\n            init () {\n                FS.error();\n            },\n            createDataFile () {\n                FS.error();\n            },\n            createPreloadedFile () {\n                FS.error();\n            },\n            createLazyFile () {\n                FS.error();\n            },\n            open () {\n                FS.error();\n            },\n            mkdev () {\n                FS.error();\n            },\n            registerDevice () {\n                FS.error();\n            },\n            analyzePath () {\n                FS.error();\n            },\n            ErrnoError () {\n                FS.error();\n            }\n        };\n        function createExportWrapper(name, nargs) {\n            return (...args)=>{\n                assert(runtimeInitialized, `native function \\`${name}\\` called before runtime initialization`);\n                var f = wasmExports[name];\n                assert(f, `exported native function \\`${name}\\` not found`);\n                // Only assert for too many arguments. Too few can be valid since the missing arguments will be zero filled.\n                assert(args.length <= nargs, `native function \\`${name}\\` called with ${args.length} args but expects ${nargs}`);\n                return f(...args);\n            };\n        }\n        var wasmBinaryFile;\n        function findWasmBinary() {\n            return locateFile('optimizer.wasm');\n        }\n        function getBinarySync(file) {\n            if (file == wasmBinaryFile && wasmBinary) return new Uint8Array(wasmBinary);\n            if (readBinary) return readBinary(file);\n            throw 'both async and sync fetching of the wasm failed';\n        }\n        async function getWasmBinary(binaryFile) {\n            // If we don't have the binary yet, load it asynchronously using readAsync.\n            if (!wasmBinary) // Fetch the binary using readAsync\n            try {\n                var response = await readAsync(binaryFile);\n                return new Uint8Array(response);\n            } catch  {\n            // Fall back to getBinarySync below;\n            }\n            // Otherwise, getBinarySync should be able to get it synchronously\n            return getBinarySync(binaryFile);\n        }\n        async function instantiateArrayBuffer(binaryFile, imports) {\n            try {\n                var binary = await getWasmBinary(binaryFile);\n                var instance = await WebAssembly.instantiate(binary, imports);\n                return instance;\n            } catch (reason) {\n                err(`failed to asynchronously prepare wasm: ${reason}`);\n                // Warn on some common problems.\n                if (isFileURI(wasmBinaryFile)) err(`warning: Loading from a file URI (${wasmBinaryFile}) is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing`);\n                abort(reason);\n            }\n        }\n        async function instantiateAsync(binary, binaryFile, imports) {\n            if (!binary && typeof WebAssembly.instantiateStreaming == 'function') try {\n                var response = fetch(binaryFile, {\n                    credentials: 'same-origin'\n                });\n                var instantiationResult = await WebAssembly.instantiateStreaming(response, imports);\n                return instantiationResult;\n            } catch (reason) {\n                // We expect the most common failure cause to be a bad MIME type for the binary,\n                // in which case falling back to ArrayBuffer instantiation should work.\n                err(`wasm streaming compile failed: ${reason}`);\n                err('falling back to ArrayBuffer instantiation');\n            // fall back of instantiateArrayBuffer below\n            }\n            return instantiateArrayBuffer(binaryFile, imports);\n        }\n        function getWasmImports() {\n            // prepare imports\n            return {\n                'env': wasmImports,\n                'wasi_snapshot_preview1': wasmImports\n            };\n        }\n        // Create the wasm instance.\n        // Receives the wasm imports, returns the exports.\n        async function createWasm() {\n            // Load the wasm module and create an instance of using native support in the JS engine.\n            // handle a generated wasm instance, receiving its exports and\n            // performing other necessary setup\n            /** @param {WebAssembly.Module=} module*/ function receiveInstance(instance, module1) {\n                wasmExports = instance.exports;\n                wasmMemory = wasmExports['memory'];\n                assert(wasmMemory, 'memory not found in wasm exports');\n                updateMemoryViews();\n                wasmTable = wasmExports['__indirect_function_table'];\n                assert(wasmTable, 'table not found in wasm exports');\n                assignWasmExports(wasmExports);\n                removeRunDependency('wasm-instantiate');\n                return wasmExports;\n            }\n            // wait for the pthread pool (if any)\n            addRunDependency('wasm-instantiate');\n            // Prefer streaming instantiation if available.\n            // Async compilation can be confusing when an error on the page overwrites Module\n            // (for example, if the order of elements is wrong, and the one defining Module is\n            // later), so we save Module and check it later.\n            var trueModule = Module;\n            function receiveInstantiationResult(result) {\n                // 'result' is a ResultObject object which has both the module and instance.\n                // receiveInstance() will swap in the exports (to Module.asm) so they can be called\n                assert(Module === trueModule, 'the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?');\n                trueModule = null;\n                // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.\n                // When the regression is fixed, can restore the above PTHREADS-enabled path.\n                return receiveInstance(result['instance']);\n            }\n            var info = getWasmImports();\n            // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback\n            // to manually instantiate the Wasm module themselves. This allows pages to\n            // run the instantiation parallel to any other async startup actions they are\n            // performing.\n            // Also pthreads and wasm workers initialize the wasm instance through this\n            // path.\n            if (Module['instantiateWasm']) return new Promise((resolve, reject)=>{\n                try {\n                    Module['instantiateWasm'](info, (mod, inst)=>{\n                        resolve(receiveInstance(mod, inst));\n                    });\n                } catch (e) {\n                    err(`Module.instantiateWasm callback failed with error: ${e}`);\n                    reject(e);\n                }\n            });\n            wasmBinaryFile ??= findWasmBinary();\n            var result = await instantiateAsync(wasmBinary, wasmBinaryFile, info);\n            var exports = receiveInstantiationResult(result);\n            return exports;\n        }\n        // end include: preamble.js\n        // Begin JS library code\n        class ExitStatus {\n            name = 'ExitStatus';\n            constructor(status){\n                this.message = `Program terminated with exit(${status})`;\n                this.status = status;\n            }\n        }\n        var callRuntimeCallbacks = (callbacks)=>{\n            while(callbacks.length > 0)// Pass the module as the first argument.\n            callbacks.shift()(Module);\n        };\n        var onPostRuns = [];\n        var addOnPostRun = (cb)=>onPostRuns.push(cb);\n        var onPreRuns = [];\n        var addOnPreRun = (cb)=>onPreRuns.push(cb);\n        /**\n     * @param {number} ptr\n     * @param {string} type\n     */ function getValue(ptr, type = 'i8') {\n            if (type.endsWith('*')) type = '*';\n            switch(type){\n                case 'i1':\n                    return HEAP8[ptr];\n                case 'i8':\n                    return HEAP8[ptr];\n                case 'i16':\n                    return HEAP16[ptr >> 1];\n                case 'i32':\n                    return HEAP32[ptr >> 2];\n                case 'i64':\n                    return HEAP64[ptr >> 3];\n                case 'float':\n                    return HEAPF32[ptr >> 2];\n                case 'double':\n                    return HEAPF64[ptr >> 3];\n                case '*':\n                    return HEAPU32[ptr >> 2];\n                default:\n                    abort(`invalid type for getValue: ${type}`);\n            }\n        }\n        var noExitRuntime = true;\n        var ptrToString = (ptr)=>{\n            assert(typeof ptr === 'number');\n            // With CAN_ADDRESS_2GB or MEMORY64, pointers are already unsigned.\n            ptr >>>= 0;\n            return '0x' + ptr.toString(16).padStart(8, '0');\n        };\n        /**\n     * @param {number} ptr\n     * @param {number} value\n     * @param {string} type\n     */ function setValue(ptr, value, type = 'i8') {\n            if (type.endsWith('*')) type = '*';\n            switch(type){\n                case 'i1':\n                    HEAP8[ptr] = value;\n                    break;\n                case 'i8':\n                    HEAP8[ptr] = value;\n                    break;\n                case 'i16':\n                    HEAP16[ptr >> 1] = value;\n                    break;\n                case 'i32':\n                    HEAP32[ptr >> 2] = value;\n                    break;\n                case 'i64':\n                    HEAP64[ptr >> 3] = BigInt(value);\n                    break;\n                case 'float':\n                    HEAPF32[ptr >> 2] = value;\n                    break;\n                case 'double':\n                    HEAPF64[ptr >> 3] = value;\n                    break;\n                case '*':\n                    HEAPU32[ptr >> 2] = value;\n                    break;\n                default:\n                    abort(`invalid type for setValue: ${type}`);\n            }\n        }\n        var stackRestore = (val)=>__emscripten_stack_restore(val);\n        var stackSave = ()=>_emscripten_stack_get_current();\n        var warnOnce = (text)=>{\n            warnOnce.shown ||= {};\n            if (!warnOnce.shown[text]) {\n                warnOnce.shown[text] = 1;\n                err(text);\n            }\n        };\n        class ExceptionInfo {\n            // excPtr - Thrown object pointer to wrap. Metadata pointer is calculated from it.\n            constructor(excPtr){\n                this.excPtr = excPtr;\n                this.ptr = excPtr - 24;\n            }\n            set_type(type) {\n                HEAPU32[this.ptr + 4 >> 2] = type;\n            }\n            get_type() {\n                return HEAPU32[this.ptr + 4 >> 2];\n            }\n            set_destructor(destructor) {\n                HEAPU32[this.ptr + 8 >> 2] = destructor;\n            }\n            get_destructor() {\n                return HEAPU32[this.ptr + 8 >> 2];\n            }\n            set_caught(caught) {\n                caught = caught ? 1 : 0;\n                HEAP8[this.ptr + 12] = caught;\n            }\n            get_caught() {\n                return HEAP8[this.ptr + 12] != 0;\n            }\n            set_rethrown(rethrown) {\n                rethrown = rethrown ? 1 : 0;\n                HEAP8[this.ptr + 13] = rethrown;\n            }\n            get_rethrown() {\n                return HEAP8[this.ptr + 13] != 0;\n            }\n            // Initialize native structure fields. Should be called once after allocated.\n            init(type, destructor) {\n                this.set_adjusted_ptr(0);\n                this.set_type(type);\n                this.set_destructor(destructor);\n            }\n            set_adjusted_ptr(adjustedPtr) {\n                HEAPU32[this.ptr + 16 >> 2] = adjustedPtr;\n            }\n            get_adjusted_ptr() {\n                return HEAPU32[this.ptr + 16 >> 2];\n            }\n        }\n        var exceptionLast = 0;\n        var uncaughtExceptionCount = 0;\n        var ___cxa_throw = (ptr, type, destructor)=>{\n            var info = new ExceptionInfo(ptr);\n            // Initialize ExceptionInfo content after it was allocated in __cxa_allocate_exception.\n            info.init(type, destructor);\n            exceptionLast = ptr;\n            uncaughtExceptionCount++;\n            assert(false, 'Exception thrown, but exception catching is not enabled. Compile with -sNO_DISABLE_EXCEPTION_CATCHING or -sEXCEPTION_CATCHING_ALLOWED=[..] to catch.');\n        };\n        var __abort_js = ()=>abort('native code called abort()');\n        var AsciiToString = (ptr)=>{\n            var str = '';\n            while(true){\n                var ch = HEAPU8[ptr++];\n                if (!ch) return str;\n                str += String.fromCharCode(ch);\n            }\n        };\n        var awaitingDependencies = {};\n        var registeredTypes = {};\n        var typeDependencies = {};\n        var BindingError = class BindingError extends Error {\n            constructor(message){\n                super(message);\n                this.name = 'BindingError';\n            }\n        };\n        var throwBindingError = (message)=>{\n            throw new BindingError(message);\n        };\n        /** @param {Object=} options */ function sharedRegisterType(rawType, registeredInstance, options = {}) {\n            var name = registeredInstance.name;\n            if (!rawType) throwBindingError(`type \"${name}\" must have a positive integer typeid pointer`);\n            if (registeredTypes.hasOwnProperty(rawType)) {\n                if (options.ignoreDuplicateRegistrations) return;\n                else throwBindingError(`Cannot register type '${name}' twice`);\n            }\n            registeredTypes[rawType] = registeredInstance;\n            delete typeDependencies[rawType];\n            if (awaitingDependencies.hasOwnProperty(rawType)) {\n                var callbacks = awaitingDependencies[rawType];\n                delete awaitingDependencies[rawType];\n                callbacks.forEach((cb)=>cb());\n            }\n        }\n        /** @param {Object=} options */ function registerType(rawType, registeredInstance, options = {}) {\n            if (registeredInstance.argPackAdvance === undefined) throw new TypeError('registerType registeredInstance requires argPackAdvance');\n            return sharedRegisterType(rawType, registeredInstance, options);\n        }\n        var integerReadValueFromPointer = (name, width, signed)=>{\n            // integers are quite common, so generate very specialized functions\n            switch(width){\n                case 1:\n                    return signed ? (pointer)=>HEAP8[pointer] : (pointer)=>HEAPU8[pointer];\n                case 2:\n                    return signed ? (pointer)=>HEAP16[pointer >> 1] : (pointer)=>HEAPU16[pointer >> 1];\n                case 4:\n                    return signed ? (pointer)=>HEAP32[pointer >> 2] : (pointer)=>HEAPU32[pointer >> 2];\n                case 8:\n                    return signed ? (pointer)=>HEAP64[pointer >> 3] : (pointer)=>HEAPU64[pointer >> 3];\n                default:\n                    throw new TypeError(`invalid integer width (${width}): ${name}`);\n            }\n        };\n        var embindRepr = (v)=>{\n            if (v === null) return 'null';\n            var t = typeof v;\n            if (t === 'object' || t === 'array' || t === 'function') return v.toString();\n            else return '' + v;\n        };\n        var assertIntegerRange = (typeName, value, minRange, maxRange)=>{\n            if (value < minRange || value > maxRange) throw new TypeError(`Passing a number \"${embindRepr(value)}\" from JS side to C/C++ side to an argument of type \"${typeName}\", which is outside the valid range [${minRange}, ${maxRange}]!`);\n        };\n        /** @suppress {globalThis} */ var __embind_register_bigint = (primitiveType, name, size, minRange, maxRange)=>{\n            name = AsciiToString(name);\n            const isUnsignedType = minRange === 0n;\n            let fromWireType = (value)=>value;\n            if (isUnsignedType) {\n                // uint64 get converted to int64 in ABI, fix them up like we do for 32-bit integers.\n                const bitSize = size * 8;\n                fromWireType = (value)=>{\n                    return BigInt.asUintN(bitSize, value);\n                };\n                maxRange = fromWireType(maxRange);\n            }\n            registerType(primitiveType, {\n                name: name,\n                'fromWireType': fromWireType,\n                'toWireType': (destructors, value)=>{\n                    if (typeof value == \"number\") value = BigInt(value);\n                    else if (typeof value != \"bigint\") throw new TypeError(`Cannot convert \"${embindRepr(value)}\" to ${this.name}`);\n                    assertIntegerRange(name, value, minRange, maxRange);\n                    return value;\n                },\n                argPackAdvance: GenericWireTypeSize,\n                'readValueFromPointer': integerReadValueFromPointer(name, size, !isUnsignedType),\n                destructorFunction: null\n            });\n        };\n        var GenericWireTypeSize = 8;\n        /** @suppress {globalThis} */ var __embind_register_bool = (rawType, name, trueValue, falseValue)=>{\n            name = AsciiToString(name);\n            registerType(rawType, {\n                name: name,\n                'fromWireType': function(wt) {\n                    // ambiguous emscripten ABI: sometimes return values are\n                    // true or false, and sometimes integers (0 or 1)\n                    return !!wt;\n                },\n                'toWireType': function(destructors, o) {\n                    return o ? trueValue : falseValue;\n                },\n                argPackAdvance: GenericWireTypeSize,\n                'readValueFromPointer': function(pointer) {\n                    return this['fromWireType'](HEAPU8[pointer]);\n                },\n                destructorFunction: null\n            });\n        };\n        var shallowCopyInternalPointer = (o)=>{\n            return {\n                count: o.count,\n                deleteScheduled: o.deleteScheduled,\n                preservePointerOnDelete: o.preservePointerOnDelete,\n                ptr: o.ptr,\n                ptrType: o.ptrType,\n                smartPtr: o.smartPtr,\n                smartPtrType: o.smartPtrType\n            };\n        };\n        var throwInstanceAlreadyDeleted = (obj)=>{\n            function getInstanceTypeName(handle) {\n                return handle.$$.ptrType.registeredClass.name;\n            }\n            throwBindingError(getInstanceTypeName(obj) + ' instance already deleted');\n        };\n        var finalizationRegistry = false;\n        var detachFinalizer = (handle)=>{};\n        var runDestructor = ($$)=>{\n            if ($$.smartPtr) $$.smartPtrType.rawDestructor($$.smartPtr);\n            else $$.ptrType.registeredClass.rawDestructor($$.ptr);\n        };\n        var releaseClassHandle = ($$)=>{\n            $$.count.value -= 1;\n            var toDelete = 0 === $$.count.value;\n            if (toDelete) runDestructor($$);\n        };\n        var downcastPointer = (ptr, ptrClass, desiredClass)=>{\n            if (ptrClass === desiredClass) return ptr;\n            if (undefined === desiredClass.baseClass) return null; // no conversion\n            var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);\n            if (rv === null) return null;\n            return desiredClass.downcast(rv);\n        };\n        var registeredPointers = {};\n        var registeredInstances = {};\n        var getBasestPointer = (class_, ptr)=>{\n            if (ptr === undefined) throwBindingError('ptr should not be undefined');\n            while(class_.baseClass){\n                ptr = class_.upcast(ptr);\n                class_ = class_.baseClass;\n            }\n            return ptr;\n        };\n        var getInheritedInstance = (class_, ptr)=>{\n            ptr = getBasestPointer(class_, ptr);\n            return registeredInstances[ptr];\n        };\n        var InternalError = class InternalError extends Error {\n            constructor(message){\n                super(message);\n                this.name = 'InternalError';\n            }\n        };\n        var throwInternalError = (message)=>{\n            throw new InternalError(message);\n        };\n        var makeClassHandle = (prototype, record)=>{\n            if (!record.ptrType || !record.ptr) throwInternalError('makeClassHandle requires ptr and ptrType');\n            var hasSmartPtrType = !!record.smartPtrType;\n            var hasSmartPtr = !!record.smartPtr;\n            if (hasSmartPtrType !== hasSmartPtr) throwInternalError('Both smartPtrType and smartPtr must be specified');\n            record.count = {\n                value: 1\n            };\n            return attachFinalizer(Object.create(prototype, {\n                $$: {\n                    value: record,\n                    writable: true\n                }\n            }));\n        };\n        /** @suppress {globalThis} */ function RegisteredPointer_fromWireType(ptr) {\n            // ptr is a raw pointer (or a raw smartpointer)\n            // rawPointer is a maybe-null raw pointer\n            var rawPointer = this.getPointee(ptr);\n            if (!rawPointer) {\n                this.destructor(ptr);\n                return null;\n            }\n            var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);\n            if (undefined !== registeredInstance) {\n                // JS object has been neutered, time to repopulate it\n                if (0 === registeredInstance.$$.count.value) {\n                    registeredInstance.$$.ptr = rawPointer;\n                    registeredInstance.$$.smartPtr = ptr;\n                    return registeredInstance['clone']();\n                } else {\n                    // else, just increment reference count on existing object\n                    // it already has a reference to the smart pointer\n                    var rv = registeredInstance['clone']();\n                    this.destructor(ptr);\n                    return rv;\n                }\n            }\n            function makeDefaultHandle() {\n                if (this.isSmartPointer) return makeClassHandle(this.registeredClass.instancePrototype, {\n                    ptrType: this.pointeeType,\n                    ptr: rawPointer,\n                    smartPtrType: this,\n                    smartPtr: ptr\n                });\n                else return makeClassHandle(this.registeredClass.instancePrototype, {\n                    ptrType: this,\n                    ptr: ptr\n                });\n            }\n            var actualType = this.registeredClass.getActualType(rawPointer);\n            var registeredPointerRecord = registeredPointers[actualType];\n            if (!registeredPointerRecord) return makeDefaultHandle.call(this);\n            var toType;\n            if (this.isConst) toType = registeredPointerRecord.constPointerType;\n            else toType = registeredPointerRecord.pointerType;\n            var dp = downcastPointer(rawPointer, this.registeredClass, toType.registeredClass);\n            if (dp === null) return makeDefaultHandle.call(this);\n            if (this.isSmartPointer) return makeClassHandle(toType.registeredClass.instancePrototype, {\n                ptrType: toType,\n                ptr: dp,\n                smartPtrType: this,\n                smartPtr: ptr\n            });\n            else return makeClassHandle(toType.registeredClass.instancePrototype, {\n                ptrType: toType,\n                ptr: dp\n            });\n        }\n        var attachFinalizer = (handle)=>{\n            if ('undefined' === typeof FinalizationRegistry) {\n                attachFinalizer = (handle)=>handle;\n                return handle;\n            }\n            // If the running environment has a FinalizationRegistry (see\n            // https://github.com/tc39/proposal-weakrefs), then attach finalizers\n            // for class handles.  We check for the presence of FinalizationRegistry\n            // at run-time, not build-time.\n            finalizationRegistry = new FinalizationRegistry((info)=>{\n                console.warn(info.leakWarning);\n                releaseClassHandle(info.$$);\n            });\n            attachFinalizer = (handle)=>{\n                var $$ = handle.$$;\n                var hasSmartPtr = !!$$.smartPtr;\n                if (hasSmartPtr) {\n                    // We should not call the destructor on raw pointers in case other code expects the pointee to live\n                    var info = {\n                        $$: $$\n                    };\n                    // Create a warning as an Error instance in advance so that we can store\n                    // the current stacktrace and point to it when / if a leak is detected.\n                    // This is more useful than the empty stacktrace of `FinalizationRegistry`\n                    // callback.\n                    var cls = $$.ptrType.registeredClass;\n                    var err = new Error(`Embind found a leaked C++ instance ${cls.name} <${ptrToString($$.ptr)}>.\\n` + \"We'll free it automatically in this case, but this functionality is not reliable across various environments.\\n\" + \"Make sure to invoke .delete() manually once you're done with the instance instead.\\n\" + \"Originally allocated\"); // `.stack` will add \"at ...\" after this sentence\n                    if ('captureStackTrace' in Error) Error.captureStackTrace(err, RegisteredPointer_fromWireType);\n                    info.leakWarning = err.stack.replace(/^Error: /, '');\n                    finalizationRegistry.register(handle, info, handle);\n                }\n                return handle;\n            };\n            detachFinalizer = (handle)=>finalizationRegistry.unregister(handle);\n            return attachFinalizer(handle);\n        };\n        var deletionQueue = [];\n        var flushPendingDeletes = ()=>{\n            while(deletionQueue.length){\n                var obj = deletionQueue.pop();\n                obj.$$.deleteScheduled = false;\n                obj['delete']();\n            }\n        };\n        var delayFunction;\n        var init_ClassHandle = ()=>{\n            let proto = ClassHandle.prototype;\n            Object.assign(proto, {\n                \"isAliasOf\" (other) {\n                    if (!(this instanceof ClassHandle)) return false;\n                    if (!(other instanceof ClassHandle)) return false;\n                    var leftClass = this.$$.ptrType.registeredClass;\n                    var left = this.$$.ptr;\n                    other.$$ = /** @type {Object} */ other.$$;\n                    var rightClass = other.$$.ptrType.registeredClass;\n                    var right = other.$$.ptr;\n                    while(leftClass.baseClass){\n                        left = leftClass.upcast(left);\n                        leftClass = leftClass.baseClass;\n                    }\n                    while(rightClass.baseClass){\n                        right = rightClass.upcast(right);\n                        rightClass = rightClass.baseClass;\n                    }\n                    return leftClass === rightClass && left === right;\n                },\n                \"clone\" () {\n                    if (!this.$$.ptr) throwInstanceAlreadyDeleted(this);\n                    if (this.$$.preservePointerOnDelete) {\n                        this.$$.count.value += 1;\n                        return this;\n                    } else {\n                        var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), {\n                            $$: {\n                                value: shallowCopyInternalPointer(this.$$)\n                            }\n                        }));\n                        clone.$$.count.value += 1;\n                        clone.$$.deleteScheduled = false;\n                        return clone;\n                    }\n                },\n                \"delete\" () {\n                    if (!this.$$.ptr) throwInstanceAlreadyDeleted(this);\n                    if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) throwBindingError('Object already scheduled for deletion');\n                    detachFinalizer(this);\n                    releaseClassHandle(this.$$);\n                    if (!this.$$.preservePointerOnDelete) {\n                        this.$$.smartPtr = undefined;\n                        this.$$.ptr = undefined;\n                    }\n                },\n                \"isDeleted\" () {\n                    return !this.$$.ptr;\n                },\n                \"deleteLater\" () {\n                    if (!this.$$.ptr) throwInstanceAlreadyDeleted(this);\n                    if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) throwBindingError('Object already scheduled for deletion');\n                    deletionQueue.push(this);\n                    if (deletionQueue.length === 1 && delayFunction) delayFunction(flushPendingDeletes);\n                    this.$$.deleteScheduled = true;\n                    return this;\n                }\n            });\n            // Support `using ...` from https://github.com/tc39/proposal-explicit-resource-management.\n            const symbolDispose = Symbol.dispose;\n            if (symbolDispose) proto[symbolDispose] = proto['delete'];\n        };\n        /** @constructor */ function ClassHandle() {}\n        var createNamedFunction = (name, func)=>Object.defineProperty(func, 'name', {\n                value: name\n            });\n        var ensureOverloadTable = (proto, methodName, humanName)=>{\n            if (undefined === proto[methodName].overloadTable) {\n                var prevFunc = proto[methodName];\n                // Inject an overload resolver function that routes to the appropriate overload based on the number of arguments.\n                proto[methodName] = function(...args) {\n                    // TODO This check can be removed in -O3 level \"unsafe\" optimizations.\n                    if (!proto[methodName].overloadTable.hasOwnProperty(args.length)) throwBindingError(`Function '${humanName}' called with an invalid number of arguments (${args.length}) - expects one of (${proto[methodName].overloadTable})!`);\n                    return proto[methodName].overloadTable[args.length].apply(this, args);\n                };\n                // Move the previous function into the overload table.\n                proto[methodName].overloadTable = [];\n                proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;\n            }\n        };\n        /** @param {number=} numArguments */ var exposePublicSymbol = (name, value, numArguments)=>{\n            if (Module.hasOwnProperty(name)) {\n                if (undefined === numArguments || undefined !== Module[name].overloadTable && undefined !== Module[name].overloadTable[numArguments]) throwBindingError(`Cannot register public name '${name}' twice`);\n                // We are exposing a function with the same name as an existing function. Create an overload table and a function selector\n                // that routes between the two.\n                ensureOverloadTable(Module, name, name);\n                if (Module[name].overloadTable.hasOwnProperty(numArguments)) throwBindingError(`Cannot register multiple overloads of a function with the same number of arguments (${numArguments})!`);\n                // Add the new function into the overload table.\n                Module[name].overloadTable[numArguments] = value;\n            } else {\n                Module[name] = value;\n                Module[name].argCount = numArguments;\n            }\n        };\n        var char_0 = 48;\n        var char_9 = 57;\n        var makeLegalFunctionName = (name)=>{\n            assert(typeof name === 'string');\n            name = name.replace(/[^a-zA-Z0-9_]/g, '$');\n            var f = name.charCodeAt(0);\n            if (f >= char_0 && f <= char_9) return `_${name}`;\n            return name;\n        };\n        /** @constructor */ function RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast) {\n            this.name = name;\n            this.constructor = constructor;\n            this.instancePrototype = instancePrototype;\n            this.rawDestructor = rawDestructor;\n            this.baseClass = baseClass;\n            this.getActualType = getActualType;\n            this.upcast = upcast;\n            this.downcast = downcast;\n            this.pureVirtualFunctions = [];\n        }\n        var upcastPointer = (ptr, ptrClass, desiredClass)=>{\n            while(ptrClass !== desiredClass){\n                if (!ptrClass.upcast) throwBindingError(`Expected null or instance of ${desiredClass.name}, got an instance of ${ptrClass.name}`);\n                ptr = ptrClass.upcast(ptr);\n                ptrClass = ptrClass.baseClass;\n            }\n            return ptr;\n        };\n        /** @suppress {globalThis} */ function constNoSmartPtrRawPointerToWireType(destructors, handle) {\n            if (handle === null) {\n                if (this.isReference) throwBindingError(`null is not a valid ${this.name}`);\n                return 0;\n            }\n            if (!handle.$$) throwBindingError(`Cannot pass \"${embindRepr(handle)}\" as a ${this.name}`);\n            if (!handle.$$.ptr) throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);\n            var handleClass = handle.$$.ptrType.registeredClass;\n            var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n            return ptr;\n        }\n        /** @suppress {globalThis} */ function genericPointerToWireType(destructors, handle) {\n            var ptr;\n            if (handle === null) {\n                if (this.isReference) throwBindingError(`null is not a valid ${this.name}`);\n                if (this.isSmartPointer) {\n                    ptr = this.rawConstructor();\n                    if (destructors !== null) destructors.push(this.rawDestructor, ptr);\n                    return ptr;\n                } else return 0;\n            }\n            if (!handle || !handle.$$) throwBindingError(`Cannot pass \"${embindRepr(handle)}\" as a ${this.name}`);\n            if (!handle.$$.ptr) throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);\n            if (!this.isConst && handle.$$.ptrType.isConst) throwBindingError(`Cannot convert argument of type ${handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name} to parameter type ${this.name}`);\n            var handleClass = handle.$$.ptrType.registeredClass;\n            ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n            if (this.isSmartPointer) {\n                // TODO: this is not strictly true\n                // We could support BY_EMVAL conversions from raw pointers to smart pointers\n                // because the smart pointer can hold a reference to the handle\n                if (undefined === handle.$$.smartPtr) throwBindingError('Passing raw pointer to smart pointer is illegal');\n                switch(this.sharingPolicy){\n                    case 0:\n                        // no upcasting\n                        if (handle.$$.smartPtrType === this) ptr = handle.$$.smartPtr;\n                        else throwBindingError(`Cannot convert argument of type ${handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name} to parameter type ${this.name}`);\n                        break;\n                    case 1:\n                        ptr = handle.$$.smartPtr;\n                        break;\n                    case 2:\n                        if (handle.$$.smartPtrType === this) ptr = handle.$$.smartPtr;\n                        else {\n                            var clonedHandle = handle['clone']();\n                            ptr = this.rawShare(ptr, Emval.toHandle(()=>clonedHandle['delete']()));\n                            if (destructors !== null) destructors.push(this.rawDestructor, ptr);\n                        }\n                        break;\n                    default:\n                        throwBindingError('Unsupporting sharing policy');\n                }\n            }\n            return ptr;\n        }\n        /** @suppress {globalThis} */ function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {\n            if (handle === null) {\n                if (this.isReference) throwBindingError(`null is not a valid ${this.name}`);\n                return 0;\n            }\n            if (!handle.$$) throwBindingError(`Cannot pass \"${embindRepr(handle)}\" as a ${this.name}`);\n            if (!handle.$$.ptr) throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);\n            if (handle.$$.ptrType.isConst) throwBindingError(`Cannot convert argument of type ${handle.$$.ptrType.name} to parameter type ${this.name}`);\n            var handleClass = handle.$$.ptrType.registeredClass;\n            var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n            return ptr;\n        }\n        /** @suppress {globalThis} */ function readPointer(pointer) {\n            return this['fromWireType'](HEAPU32[pointer >> 2]);\n        }\n        var init_RegisteredPointer = ()=>{\n            Object.assign(RegisteredPointer.prototype, {\n                getPointee (ptr) {\n                    if (this.rawGetPointee) ptr = this.rawGetPointee(ptr);\n                    return ptr;\n                },\n                destructor (ptr) {\n                    this.rawDestructor?.(ptr);\n                },\n                argPackAdvance: GenericWireTypeSize,\n                'readValueFromPointer': readPointer,\n                'fromWireType': RegisteredPointer_fromWireType\n            });\n        };\n        /** @constructor\n      @param {*=} pointeeType,\n      @param {*=} sharingPolicy,\n      @param {*=} rawGetPointee,\n      @param {*=} rawConstructor,\n      @param {*=} rawShare,\n      @param {*=} rawDestructor,\n       */ function RegisteredPointer(name, registeredClass, isReference, isConst, // smart pointer properties\n        isSmartPointer, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor) {\n            this.name = name;\n            this.registeredClass = registeredClass;\n            this.isReference = isReference;\n            this.isConst = isConst;\n            // smart pointer properties\n            this.isSmartPointer = isSmartPointer;\n            this.pointeeType = pointeeType;\n            this.sharingPolicy = sharingPolicy;\n            this.rawGetPointee = rawGetPointee;\n            this.rawConstructor = rawConstructor;\n            this.rawShare = rawShare;\n            this.rawDestructor = rawDestructor;\n            if (!isSmartPointer && registeredClass.baseClass === undefined) {\n                if (isConst) {\n                    this['toWireType'] = constNoSmartPtrRawPointerToWireType;\n                    this.destructorFunction = null;\n                } else {\n                    this['toWireType'] = nonConstNoSmartPtrRawPointerToWireType;\n                    this.destructorFunction = null;\n                }\n            } else this['toWireType'] = genericPointerToWireType;\n        }\n        /** @param {number=} numArguments */ var replacePublicSymbol = (name, value, numArguments)=>{\n            if (!Module.hasOwnProperty(name)) throwInternalError('Replacing nonexistent public symbol');\n            // If there's an overload table for this symbol, replace the symbol in the overload table instead.\n            if (undefined !== Module[name].overloadTable && undefined !== numArguments) Module[name].overloadTable[numArguments] = value;\n            else {\n                Module[name] = value;\n                Module[name].argCount = numArguments;\n            }\n        };\n        var wasmTableMirror = [];\n        /** @type {WebAssembly.Table} */ var wasmTable;\n        var getWasmTableEntry = (funcPtr)=>{\n            var func = wasmTableMirror[funcPtr];\n            if (!func) /** @suppress {checkTypes} */ wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);\n            /** @suppress {checkTypes} */ assert(wasmTable.get(funcPtr) == func, 'JavaScript-side Wasm function table mirror is out of date!');\n            return func;\n        };\n        var embind__requireFunction = (signature, rawFunction, isAsync = false)=>{\n            assert(!isAsync, 'Async bindings are only supported with JSPI.');\n            signature = AsciiToString(signature);\n            function makeDynCaller() {\n                var rtn = getWasmTableEntry(rawFunction);\n                return rtn;\n            }\n            var fp = makeDynCaller();\n            if (typeof fp != 'function') throwBindingError(`unknown function pointer with signature ${signature}: ${rawFunction}`);\n            return fp;\n        };\n        class UnboundTypeError extends Error {\n        }\n        var getTypeName = (type)=>{\n            var ptr = ___getTypeName(type);\n            var rv = AsciiToString(ptr);\n            _free(ptr);\n            return rv;\n        };\n        var throwUnboundTypeError = (message, types)=>{\n            var unboundTypes = [];\n            var seen = {};\n            function visit(type) {\n                if (seen[type]) return;\n                if (registeredTypes[type]) return;\n                if (typeDependencies[type]) {\n                    typeDependencies[type].forEach(visit);\n                    return;\n                }\n                unboundTypes.push(type);\n                seen[type] = true;\n            }\n            types.forEach(visit);\n            throw new UnboundTypeError(`${message}: ` + unboundTypes.map(getTypeName).join([\n                ', '\n            ]));\n        };\n        var whenDependentTypesAreResolved = (myTypes, dependentTypes, getTypeConverters)=>{\n            myTypes.forEach((type)=>typeDependencies[type] = dependentTypes);\n            function onComplete(typeConverters) {\n                var myTypeConverters = getTypeConverters(typeConverters);\n                if (myTypeConverters.length !== myTypes.length) throwInternalError('Mismatched type converter count');\n                for(var i = 0; i < myTypes.length; ++i)registerType(myTypes[i], myTypeConverters[i]);\n            }\n            var typeConverters = new Array(dependentTypes.length);\n            var unregisteredTypes = [];\n            var registered = 0;\n            dependentTypes.forEach((dt, i)=>{\n                if (registeredTypes.hasOwnProperty(dt)) typeConverters[i] = registeredTypes[dt];\n                else {\n                    unregisteredTypes.push(dt);\n                    if (!awaitingDependencies.hasOwnProperty(dt)) awaitingDependencies[dt] = [];\n                    awaitingDependencies[dt].push(()=>{\n                        typeConverters[i] = registeredTypes[dt];\n                        ++registered;\n                        if (registered === unregisteredTypes.length) onComplete(typeConverters);\n                    });\n                }\n            });\n            if (0 === unregisteredTypes.length) onComplete(typeConverters);\n        };\n        var __embind_register_class = (rawType, rawPointerType, rawConstPointerType, baseClassRawType, getActualTypeSignature, getActualType, upcastSignature, upcast, downcastSignature, downcast, name, destructorSignature, rawDestructor)=>{\n            name = AsciiToString(name);\n            getActualType = embind__requireFunction(getActualTypeSignature, getActualType);\n            upcast &&= embind__requireFunction(upcastSignature, upcast);\n            downcast &&= embind__requireFunction(downcastSignature, downcast);\n            rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);\n            var legalFunctionName = makeLegalFunctionName(name);\n            exposePublicSymbol(legalFunctionName, function() {\n                // this code cannot run if baseClassRawType is zero\n                throwUnboundTypeError(`Cannot construct ${name} due to unbound types`, [\n                    baseClassRawType\n                ]);\n            });\n            whenDependentTypesAreResolved([\n                rawType,\n                rawPointerType,\n                rawConstPointerType\n            ], baseClassRawType ? [\n                baseClassRawType\n            ] : [], (base)=>{\n                base = base[0];\n                var baseClass;\n                var basePrototype;\n                if (baseClassRawType) {\n                    baseClass = base.registeredClass;\n                    basePrototype = baseClass.instancePrototype;\n                } else basePrototype = ClassHandle.prototype;\n                var constructor = createNamedFunction(name, function(...args) {\n                    if (Object.getPrototypeOf(this) !== instancePrototype) throw new BindingError(`Use 'new' to construct ${name}`);\n                    if (undefined === registeredClass.constructor_body) throw new BindingError(`${name} has no accessible constructor`);\n                    var body = registeredClass.constructor_body[args.length];\n                    if (undefined === body) throw new BindingError(`Tried to invoke ctor of ${name} with invalid number of parameters (${args.length}) - expected (${Object.keys(registeredClass.constructor_body).toString()}) parameters instead!`);\n                    return body.apply(this, args);\n                });\n                var instancePrototype = Object.create(basePrototype, {\n                    constructor: {\n                        value: constructor\n                    }\n                });\n                constructor.prototype = instancePrototype;\n                var registeredClass = new RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast);\n                if (registeredClass.baseClass) {\n                    // Keep track of class hierarchy. Used to allow sub-classes to inherit class functions.\n                    registeredClass.baseClass.__derivedClasses ??= [];\n                    registeredClass.baseClass.__derivedClasses.push(registeredClass);\n                }\n                var referenceConverter = new RegisteredPointer(name, registeredClass, true, false, false);\n                var pointerConverter = new RegisteredPointer(name + '*', registeredClass, false, false, false);\n                var constPointerConverter = new RegisteredPointer(name + ' const*', registeredClass, false, true, false);\n                registeredPointers[rawType] = {\n                    pointerType: pointerConverter,\n                    constPointerType: constPointerConverter\n                };\n                replacePublicSymbol(legalFunctionName, constructor);\n                return [\n                    referenceConverter,\n                    pointerConverter,\n                    constPointerConverter\n                ];\n            });\n        };\n        var heap32VectorToArray = (count, firstElement)=>{\n            var array = [];\n            for(var i = 0; i < count; i++)// TODO(https://github.com/emscripten-core/emscripten/issues/17310):\n            // Find a way to hoist the `>> 2` or `>> 3` out of this loop.\n            array.push(HEAPU32[firstElement + i * 4 >> 2]);\n            return array;\n        };\n        var runDestructors = (destructors)=>{\n            while(destructors.length){\n                var ptr = destructors.pop();\n                var del = destructors.pop();\n                del(ptr);\n            }\n        };\n        function usesDestructorStack(argTypes) {\n            // Skip return value at index 0 - it's not deleted here.\n            for(var i = 1; i < argTypes.length; ++i){\n                // The type does not define a destructor function - must use dynamic stack\n                if (argTypes[i] !== null && argTypes[i].destructorFunction === undefined) return true;\n            }\n            return false;\n        }\n        function checkArgCount(numArgs, minArgs, maxArgs, humanName, throwBindingError) {\n            if (numArgs < minArgs || numArgs > maxArgs) {\n                var argCountMessage = minArgs == maxArgs ? minArgs : `${minArgs} to ${maxArgs}`;\n                throwBindingError(`function ${humanName} called with ${numArgs} arguments, expected ${argCountMessage}`);\n            }\n        }\n        function createJsInvoker(argTypes, isClassMethodFunc, returns, isAsync) {\n            var needsDestructorStack = usesDestructorStack(argTypes);\n            var argCount = argTypes.length - 2;\n            var argsList = [];\n            var argsListWired = [\n                'fn'\n            ];\n            if (isClassMethodFunc) argsListWired.push('thisWired');\n            for(var i = 0; i < argCount; ++i){\n                argsList.push(`arg${i}`);\n                argsListWired.push(`arg${i}Wired`);\n            }\n            argsList = argsList.join(',');\n            argsListWired = argsListWired.join(',');\n            var invokerFnBody = `return function (${argsList}) {\\n`;\n            invokerFnBody += \"checkArgCount(arguments.length, minArgs, maxArgs, humanName, throwBindingError);\\n\";\n            if (needsDestructorStack) invokerFnBody += \"var destructors = [];\\n\";\n            var dtorStack = needsDestructorStack ? \"destructors\" : \"null\";\n            var args1 = [\n                \"humanName\",\n                \"throwBindingError\",\n                \"invoker\",\n                \"fn\",\n                \"runDestructors\",\n                \"retType\",\n                \"classParam\"\n            ];\n            if (isClassMethodFunc) invokerFnBody += `var thisWired = classParam['toWireType'](${dtorStack}, this);\\n`;\n            for(var i = 0; i < argCount; ++i){\n                invokerFnBody += `var arg${i}Wired = argType${i}['toWireType'](${dtorStack}, arg${i});\\n`;\n                args1.push(`argType${i}`);\n            }\n            invokerFnBody += (returns || isAsync ? \"var rv = \" : \"\") + `invoker(${argsListWired});\\n`;\n            var returnVal = returns ? \"rv\" : \"\";\n            if (needsDestructorStack) invokerFnBody += \"runDestructors(destructors);\\n\";\n            else for(var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i){\n                var paramName = i === 1 ? \"thisWired\" : \"arg\" + (i - 2) + \"Wired\";\n                if (argTypes[i].destructorFunction !== null) {\n                    invokerFnBody += `${paramName}_dtor(${paramName});\\n`;\n                    args1.push(`${paramName}_dtor`);\n                }\n            }\n            if (returns) invokerFnBody += \"var ret = retType['fromWireType'](rv);\\nreturn ret;\\n\";\n            invokerFnBody += \"}\\n\";\n            args1.push('checkArgCount', 'minArgs', 'maxArgs');\n            invokerFnBody = `if (arguments.length !== ${args1.length}){ throw new Error(humanName + \"Expected ${args1.length} closure arguments \" + arguments.length + \" given.\"); }\\n${invokerFnBody}`;\n            return [\n                args1,\n                invokerFnBody\n            ];\n        }\n        function getRequiredArgCount(argTypes) {\n            var requiredArgCount = argTypes.length - 2;\n            for(var i = argTypes.length - 1; i >= 2; --i){\n                if (!argTypes[i].optional) break;\n                requiredArgCount--;\n            }\n            return requiredArgCount;\n        }\n        function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc, /** boolean= */ isAsync) {\n            // humanName: a human-readable string name for the function to be generated.\n            // argTypes: An array that contains the embind type objects for all types in the function signature.\n            //    argTypes[0] is the type object for the function return value.\n            //    argTypes[1] is the type object for function this object/class type, or null if not crafting an invoker for a class method.\n            //    argTypes[2...] are the actual function parameters.\n            // classType: The embind type object for the class to be bound, or null if this is not a method of a class.\n            // cppInvokerFunc: JS Function object to the C++-side function that interops into C++ code.\n            // cppTargetFunc: Function pointer (an integer to FUNCTION_TABLE) to the target C++ function the cppInvokerFunc will end up calling.\n            // isAsync: Optional. If true, returns an async function. Async bindings are only supported with JSPI.\n            var argCount = argTypes.length;\n            if (argCount < 2) throwBindingError(\"argTypes array size mismatch! Must at least get return value and 'this' types!\");\n            assert(!isAsync, 'Async bindings are only supported with JSPI.');\n            var isClassMethodFunc = argTypes[1] !== null && classType !== null;\n            // Free functions with signature \"void function()\" do not need an invoker that marshalls between wire types.\n            // TODO: This omits argument count check - enable only at -O3 or similar.\n            //    if (ENABLE_UNSAFE_OPTS && argCount == 2 && argTypes[0].name == \"void\" && !isClassMethodFunc) {\n            //       return FUNCTION_TABLE[fn];\n            //    }\n            // Determine if we need to use a dynamic stack to store the destructors for the function parameters.\n            // TODO: Remove this completely once all function invokers are being dynamically generated.\n            var needsDestructorStack = usesDestructorStack(argTypes);\n            var returns = argTypes[0].name !== 'void';\n            var expectedArgCount = argCount - 2;\n            var minArgs = getRequiredArgCount(argTypes);\n            // Builld the arguments that will be passed into the closure around the invoker\n            // function.\n            var closureArgs = [\n                humanName,\n                throwBindingError,\n                cppInvokerFunc,\n                cppTargetFunc,\n                runDestructors,\n                argTypes[0],\n                argTypes[1]\n            ];\n            for(var i = 0; i < argCount - 2; ++i)closureArgs.push(argTypes[i + 2]);\n            if (!needsDestructorStack) {\n                // Skip return value at index 0 - it's not deleted here. Also skip class type if not a method.\n                for(var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i)if (argTypes[i].destructorFunction !== null) closureArgs.push(argTypes[i].destructorFunction);\n            }\n            closureArgs.push(checkArgCount, minArgs, expectedArgCount);\n            let [args, invokerFnBody] = createJsInvoker(argTypes, isClassMethodFunc, returns, isAsync);\n            var invokerFn = new Function(...args, invokerFnBody)(...closureArgs);\n            return createNamedFunction(humanName, invokerFn);\n        }\n        var __embind_register_class_constructor = (rawClassType, argCount, rawArgTypesAddr, invokerSignature, invoker, rawConstructor)=>{\n            assert(argCount > 0);\n            var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n            invoker = embind__requireFunction(invokerSignature, invoker);\n            var args = [\n                rawConstructor\n            ];\n            var destructors = [];\n            whenDependentTypesAreResolved([], [\n                rawClassType\n            ], (classType)=>{\n                classType = classType[0];\n                var humanName = `constructor ${classType.name}`;\n                if (undefined === classType.registeredClass.constructor_body) classType.registeredClass.constructor_body = [];\n                if (undefined !== classType.registeredClass.constructor_body[argCount - 1]) throw new BindingError(`Cannot register multiple constructors with identical number of parameters (${argCount - 1}) for class '${classType.name}'! Overload resolution is currently only performed using the parameter count, not actual type info!`);\n                classType.registeredClass.constructor_body[argCount - 1] = ()=>{\n                    throwUnboundTypeError(`Cannot construct ${classType.name} due to unbound types`, rawArgTypes);\n                };\n                whenDependentTypesAreResolved([], rawArgTypes, (argTypes)=>{\n                    // Insert empty slot for context type (argTypes[1]).\n                    argTypes.splice(1, 0, null);\n                    classType.registeredClass.constructor_body[argCount - 1] = craftInvokerFunction(humanName, argTypes, null, invoker, rawConstructor);\n                    return [];\n                });\n                return [];\n            });\n        };\n        var getFunctionName = (signature)=>{\n            signature = signature.trim();\n            const argsIndex = signature.indexOf(\"(\");\n            if (argsIndex === -1) return signature;\n            assert(signature.endsWith(\")\"), \"Parentheses for argument names should match.\");\n            return signature.slice(0, argsIndex);\n        };\n        var __embind_register_class_function = (rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, context, isPureVirtual, isAsync, isNonnullReturn)=>{\n            var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n            methodName = AsciiToString(methodName);\n            methodName = getFunctionName(methodName);\n            rawInvoker = embind__requireFunction(invokerSignature, rawInvoker, isAsync);\n            whenDependentTypesAreResolved([], [\n                rawClassType\n            ], (classType)=>{\n                classType = classType[0];\n                var humanName = `${classType.name}.${methodName}`;\n                if (methodName.startsWith(\"@@\")) methodName = Symbol[methodName.substring(2)];\n                if (isPureVirtual) classType.registeredClass.pureVirtualFunctions.push(methodName);\n                function unboundTypesHandler() {\n                    throwUnboundTypeError(`Cannot call ${humanName} due to unbound types`, rawArgTypes);\n                }\n                var proto = classType.registeredClass.instancePrototype;\n                var method = proto[methodName];\n                if (undefined === method || undefined === method.overloadTable && method.className !== classType.name && method.argCount === argCount - 2) {\n                    // This is the first overload to be registered, OR we are replacing a\n                    // function in the base class with a function in the derived class.\n                    unboundTypesHandler.argCount = argCount - 2;\n                    unboundTypesHandler.className = classType.name;\n                    proto[methodName] = unboundTypesHandler;\n                } else {\n                    // There was an existing function with the same name registered. Set up\n                    // a function overload routing table.\n                    ensureOverloadTable(proto, methodName, humanName);\n                    proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;\n                }\n                whenDependentTypesAreResolved([], rawArgTypes, (argTypes)=>{\n                    var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context, isAsync);\n                    // Replace the initial unbound-handler-stub function with the\n                    // appropriate member function, now that all types are resolved. If\n                    // multiple overloads are registered for this function, the function\n                    // goes into an overload table.\n                    if (undefined === proto[methodName].overloadTable) {\n                        // Set argCount in case an overload is registered later\n                        memberFunction.argCount = argCount - 2;\n                        proto[methodName] = memberFunction;\n                    } else proto[methodName].overloadTable[argCount - 2] = memberFunction;\n                    return [];\n                });\n                return [];\n            });\n        };\n        var emval_freelist = [];\n        var emval_handles = [\n            0,\n            1,\n            ,\n            1,\n            null,\n            1,\n            true,\n            1,\n            false,\n            1\n        ];\n        var __emval_decref = (handle)=>{\n            if (handle > 9 && 0 === --emval_handles[handle + 1]) {\n                assert(emval_handles[handle] !== undefined, `Decref for unallocated handle.`);\n                emval_handles[handle] = undefined;\n                emval_freelist.push(handle);\n            }\n        };\n        var Emval = {\n            toValue: (handle)=>{\n                if (!handle) throwBindingError(`Cannot use deleted val. handle = ${handle}`);\n                // handle 2 is supposed to be `undefined`.\n                assert(handle === 2 || emval_handles[handle] !== undefined && handle % 2 === 0, `invalid handle: ${handle}`);\n                return emval_handles[handle];\n            },\n            toHandle: (value)=>{\n                switch(value){\n                    case undefined:\n                        return 2;\n                    case null:\n                        return 4;\n                    case true:\n                        return 6;\n                    case false:\n                        return 8;\n                    default:\n                        {\n                            const handle = emval_freelist.pop() || emval_handles.length;\n                            emval_handles[handle] = value;\n                            emval_handles[handle + 1] = 1;\n                            return handle;\n                        }\n                }\n            }\n        };\n        var EmValType = {\n            name: 'emscripten::val',\n            'fromWireType': (handle)=>{\n                var rv = Emval.toValue(handle);\n                __emval_decref(handle);\n                return rv;\n            },\n            'toWireType': (destructors, value)=>Emval.toHandle(value),\n            argPackAdvance: GenericWireTypeSize,\n            'readValueFromPointer': readPointer,\n            destructorFunction: null\n        };\n        var __embind_register_emval = (rawType)=>registerType(rawType, EmValType);\n        var floatReadValueFromPointer = (name, width)=>{\n            switch(width){\n                case 4:\n                    return function(pointer) {\n                        return this['fromWireType'](HEAPF32[pointer >> 2]);\n                    };\n                case 8:\n                    return function(pointer) {\n                        return this['fromWireType'](HEAPF64[pointer >> 3]);\n                    };\n                default:\n                    throw new TypeError(`invalid float width (${width}): ${name}`);\n            }\n        };\n        var __embind_register_float = (rawType, name, size)=>{\n            name = AsciiToString(name);\n            registerType(rawType, {\n                name: name,\n                'fromWireType': (value)=>value,\n                'toWireType': (destructors, value)=>{\n                    if (typeof value != \"number\" && typeof value != \"boolean\") throw new TypeError(`Cannot convert ${embindRepr(value)} to ${this.name}`);\n                    // The VM will perform JS to Wasm value conversion, according to the spec:\n                    // https://www.w3.org/TR/wasm-js-api-1/#towebassemblyvalue\n                    return value;\n                },\n                argPackAdvance: GenericWireTypeSize,\n                'readValueFromPointer': floatReadValueFromPointer(name, size),\n                destructorFunction: null\n            });\n        };\n        var __embind_register_function = (name, argCount, rawArgTypesAddr, signature, rawInvoker, fn, isAsync, isNonnullReturn)=>{\n            var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n            name = AsciiToString(name);\n            name = getFunctionName(name);\n            rawInvoker = embind__requireFunction(signature, rawInvoker, isAsync);\n            exposePublicSymbol(name, function() {\n                throwUnboundTypeError(`Cannot call ${name} due to unbound types`, argTypes);\n            }, argCount - 1);\n            whenDependentTypesAreResolved([], argTypes, (argTypes)=>{\n                var invokerArgsArray = [\n                    argTypes[0],\n                    null\n                ].concat(argTypes.slice(1));\n                replacePublicSymbol(name, craftInvokerFunction(name, invokerArgsArray, null, rawInvoker, fn, isAsync), argCount - 1);\n                return [];\n            });\n        };\n        /** @suppress {globalThis} */ var __embind_register_integer = (primitiveType, name, size, minRange, maxRange)=>{\n            name = AsciiToString(name);\n            const isUnsignedType = minRange === 0;\n            let fromWireType = (value)=>value;\n            if (isUnsignedType) {\n                var bitshift = 32 - 8 * size;\n                fromWireType = (value)=>value << bitshift >>> bitshift;\n                maxRange = fromWireType(maxRange);\n            }\n            registerType(primitiveType, {\n                name: name,\n                'fromWireType': fromWireType,\n                'toWireType': (destructors, value)=>{\n                    if (typeof value != \"number\" && typeof value != \"boolean\") throw new TypeError(`Cannot convert \"${embindRepr(value)}\" to ${name}`);\n                    assertIntegerRange(name, value, minRange, maxRange);\n                    // The VM will perform JS to Wasm value conversion, according to the spec:\n                    // https://www.w3.org/TR/wasm-js-api-1/#towebassemblyvalue\n                    return value;\n                },\n                argPackAdvance: GenericWireTypeSize,\n                'readValueFromPointer': integerReadValueFromPointer(name, size, minRange !== 0),\n                destructorFunction: null\n            });\n        };\n        var __embind_register_memory_view = (rawType, dataTypeIndex, name)=>{\n            var typeMapping = [\n                Int8Array,\n                Uint8Array,\n                Int16Array,\n                Uint16Array,\n                Int32Array,\n                Uint32Array,\n                Float32Array,\n                Float64Array,\n                BigInt64Array,\n                BigUint64Array\n            ];\n            var TA = typeMapping[dataTypeIndex];\n            function decodeMemoryView(handle) {\n                var size = HEAPU32[handle >> 2];\n                var data = HEAPU32[handle + 4 >> 2];\n                return new TA(HEAP8.buffer, data, size);\n            }\n            name = AsciiToString(name);\n            registerType(rawType, {\n                name: name,\n                'fromWireType': decodeMemoryView,\n                argPackAdvance: GenericWireTypeSize,\n                'readValueFromPointer': decodeMemoryView\n            }, {\n                ignoreDuplicateRegistrations: true\n            });\n        };\n        var EmValOptionalType = Object.assign({\n            optional: true\n        }, EmValType);\n        var __embind_register_optional = (rawOptionalType, rawType)=>{\n            registerType(rawOptionalType, EmValOptionalType);\n        };\n        var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite)=>{\n            assert(typeof str === 'string', `stringToUTF8Array expects a string (got ${typeof str})`);\n            // Parameter maxBytesToWrite is not optional. Negative values, 0, null,\n            // undefined and false each don't write out any bytes.\n            if (!(maxBytesToWrite > 0)) return 0;\n            var startIdx = outIdx;\n            var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.\n            for(var i = 0; i < str.length; ++i){\n                // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description\n                // and https://www.ietf.org/rfc/rfc2279.txt\n                // and https://tools.ietf.org/html/rfc3629\n                var u = str.codePointAt(i);\n                if (u <= 0x7F) {\n                    if (outIdx >= endIdx) break;\n                    heap[outIdx++] = u;\n                } else if (u <= 0x7FF) {\n                    if (outIdx + 1 >= endIdx) break;\n                    heap[outIdx++] = 0xC0 | u >> 6;\n                    heap[outIdx++] = 0x80 | u & 63;\n                } else if (u <= 0xFFFF) {\n                    if (outIdx + 2 >= endIdx) break;\n                    heap[outIdx++] = 0xE0 | u >> 12;\n                    heap[outIdx++] = 0x80 | u >> 6 & 63;\n                    heap[outIdx++] = 0x80 | u & 63;\n                } else {\n                    if (outIdx + 3 >= endIdx) break;\n                    if (u > 0x10FFFF) warnOnce('Invalid Unicode code point ' + ptrToString(u) + ' encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF).');\n                    heap[outIdx++] = 0xF0 | u >> 18;\n                    heap[outIdx++] = 0x80 | u >> 12 & 63;\n                    heap[outIdx++] = 0x80 | u >> 6 & 63;\n                    heap[outIdx++] = 0x80 | u & 63;\n                    // Gotcha: if codePoint is over 0xFFFF, it is represented as a surrogate pair in UTF-16.\n                    // We need to manually skip over the second code unit for correct iteration.\n                    i++;\n                }\n            }\n            // Null-terminate the pointer to the buffer.\n            heap[outIdx] = 0;\n            return outIdx - startIdx;\n        };\n        var stringToUTF8 = (str, outPtr, maxBytesToWrite)=>{\n            assert(typeof maxBytesToWrite == 'number', 'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');\n            return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\n        };\n        var lengthBytesUTF8 = (str)=>{\n            var len = 0;\n            for(var i = 0; i < str.length; ++i){\n                // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code\n                // unit, not a Unicode code point of the character! So decode\n                // UTF16->UTF32->UTF8.\n                // See http://unicode.org/faq/utf_bom.html#utf16-3\n                var c = str.charCodeAt(i); // possibly a lead surrogate\n                if (c <= 0x7F) len++;\n                else if (c <= 0x7FF) len += 2;\n                else if (c >= 0xD800 && c <= 0xDFFF) {\n                    len += 4;\n                    ++i;\n                } else len += 3;\n            }\n            return len;\n        };\n        var UTF8Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder() : undefined;\n        /**\n     * Given a pointer 'idx' to a null-terminated UTF8-encoded string in the given\n     * array that contains uint8 values, returns a copy of that string as a\n     * Javascript String object.\n     * heapOrArray is either a regular array, or a JavaScript typed array view.\n     * @param {number=} idx\n     * @param {number=} maxBytesToRead\n     * @return {string}\n     */ var UTF8ArrayToString = (heapOrArray, idx = 0, maxBytesToRead = NaN)=>{\n            var endIdx = idx + maxBytesToRead;\n            var endPtr = idx;\n            // TextDecoder needs to know the byte length in advance, it doesn't stop on\n            // null terminator by itself.  Also, use the length info to avoid running tiny\n            // strings through TextDecoder, since .subarray() allocates garbage.\n            // (As a tiny code save trick, compare endPtr against endIdx using a negation,\n            // so that undefined/NaN means Infinity)\n            while(heapOrArray[endPtr] && !(endPtr >= endIdx))++endPtr;\n            // When using conditional TextDecoder, skip it for short strings as the overhead of the native call is not worth it.\n            if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));\n            var str = '';\n            // If building with TextDecoder, we have already computed the string length\n            // above, so test loop end condition against that\n            while(idx < endPtr){\n                // For UTF8 byte structure, see:\n                // http://en.wikipedia.org/wiki/UTF-8#Description\n                // https://www.ietf.org/rfc/rfc2279.txt\n                // https://tools.ietf.org/html/rfc3629\n                var u0 = heapOrArray[idx++];\n                if (!(u0 & 0x80)) {\n                    str += String.fromCharCode(u0);\n                    continue;\n                }\n                var u1 = heapOrArray[idx++] & 63;\n                if ((u0 & 0xE0) == 0xC0) {\n                    str += String.fromCharCode((u0 & 31) << 6 | u1);\n                    continue;\n                }\n                var u2 = heapOrArray[idx++] & 63;\n                if ((u0 & 0xF0) == 0xE0) u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n                else {\n                    if ((u0 & 0xF8) != 0xF0) warnOnce('Invalid UTF-8 leading byte ' + ptrToString(u0) + ' encountered when deserializing a UTF-8 string in wasm memory to a JS string!');\n                    u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;\n                }\n                if (u0 < 0x10000) str += String.fromCharCode(u0);\n                else {\n                    var ch = u0 - 0x10000;\n                    str += String.fromCharCode(0xD800 | ch >> 10, 0xDC00 | ch & 0x3FF);\n                }\n            }\n            return str;\n        };\n        /**\n     * Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the\n     * emscripten HEAP, returns a copy of that string as a Javascript String object.\n     *\n     * @param {number} ptr\n     * @param {number=} maxBytesToRead - An optional length that specifies the\n     *   maximum number of bytes to read. You can omit this parameter to scan the\n     *   string until the first 0 byte. If maxBytesToRead is passed, and the string\n     *   at [ptr, ptr+maxBytesToReadr[ contains a null byte in the middle, then the\n     *   string will cut short at that byte index (i.e. maxBytesToRead will not\n     *   produce a string of exact length [ptr, ptr+maxBytesToRead[) N.B. mixing\n     *   frequent uses of UTF8ToString() with and without maxBytesToRead may throw\n     *   JS JIT optimizations off, so it is worth to consider consistently using one\n     * @return {string}\n     */ var UTF8ToString = (ptr, maxBytesToRead)=>{\n            assert(typeof ptr == 'number', `UTF8ToString expects a number (got ${typeof ptr})`);\n            return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';\n        };\n        var __embind_register_std_string = (rawType, name)=>{\n            name = AsciiToString(name);\n            var stdStringIsUTF8 = true;\n            registerType(rawType, {\n                name: name,\n                // For some method names we use string keys here since they are part of\n                // the public/external API and/or used by the runtime-generated code.\n                'fromWireType' (value) {\n                    var length = HEAPU32[value >> 2];\n                    var payload = value + 4;\n                    var str;\n                    if (stdStringIsUTF8) {\n                        var decodeStartPtr = payload;\n                        // Looping here to support possible embedded '0' bytes\n                        for(var i = 0; i <= length; ++i){\n                            var currentBytePtr = payload + i;\n                            if (i == length || HEAPU8[currentBytePtr] == 0) {\n                                var maxRead = currentBytePtr - decodeStartPtr;\n                                var stringSegment = UTF8ToString(decodeStartPtr, maxRead);\n                                if (str === undefined) str = stringSegment;\n                                else {\n                                    str += String.fromCharCode(0);\n                                    str += stringSegment;\n                                }\n                                decodeStartPtr = currentBytePtr + 1;\n                            }\n                        }\n                    } else {\n                        var a = new Array(length);\n                        for(var i = 0; i < length; ++i)a[i] = String.fromCharCode(HEAPU8[payload + i]);\n                        str = a.join('');\n                    }\n                    _free(value);\n                    return str;\n                },\n                'toWireType' (destructors, value) {\n                    if (value instanceof ArrayBuffer) value = new Uint8Array(value);\n                    var length;\n                    var valueIsOfTypeString = typeof value == 'string';\n                    // We accept `string` or array views with single byte elements\n                    if (!(valueIsOfTypeString || ArrayBuffer.isView(value) && value.BYTES_PER_ELEMENT == 1)) throwBindingError('Cannot pass non-string to std::string');\n                    if (stdStringIsUTF8 && valueIsOfTypeString) length = lengthBytesUTF8(value);\n                    else length = value.length;\n                    // assumes POINTER_SIZE alignment\n                    var base = _malloc(4 + length + 1);\n                    var ptr = base + 4;\n                    HEAPU32[base >> 2] = length;\n                    if (valueIsOfTypeString) {\n                        if (stdStringIsUTF8) stringToUTF8(value, ptr, length + 1);\n                        else for(var i = 0; i < length; ++i){\n                            var charCode = value.charCodeAt(i);\n                            if (charCode > 255) {\n                                _free(base);\n                                throwBindingError('String has UTF-16 code units that do not fit in 8 bits');\n                            }\n                            HEAPU8[ptr + i] = charCode;\n                        }\n                    } else HEAPU8.set(value, ptr);\n                    if (destructors !== null) destructors.push(_free, base);\n                    return base;\n                },\n                argPackAdvance: GenericWireTypeSize,\n                'readValueFromPointer': readPointer,\n                destructorFunction (ptr) {\n                    _free(ptr);\n                }\n            });\n        };\n        var UTF16Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder('utf-16le') : undefined;\n        var UTF16ToString = (ptr, maxBytesToRead)=>{\n            assert(ptr % 2 == 0, 'Pointer passed to UTF16ToString must be aligned to two bytes!');\n            var idx = ptr >> 1;\n            var maxIdx = idx + maxBytesToRead / 2;\n            // TextDecoder needs to know the byte length in advance, it doesn't stop on\n            // null terminator by itself.\n            // Also, use the length info to avoid running tiny strings through\n            // TextDecoder, since .subarray() allocates garbage.\n            var endIdx = idx;\n            // If maxBytesToRead is not passed explicitly, it will be undefined, and this\n            // will always evaluate to true. This saves on code size.\n            while(!(endIdx >= maxIdx) && HEAPU16[endIdx])++endIdx;\n            if (endIdx - idx > 16 && UTF16Decoder) return UTF16Decoder.decode(HEAPU16.subarray(idx, endIdx));\n            // Fallback: decode without UTF16Decoder\n            var str = '';\n            // If maxBytesToRead is not passed explicitly, it will be undefined, and the\n            // for-loop's condition will always evaluate to true. The loop is then\n            // terminated on the first null char.\n            for(var i = idx; !(i >= maxIdx); ++i){\n                var codeUnit = HEAPU16[i];\n                if (codeUnit == 0) break;\n                // fromCharCode constructs a character from a UTF-16 code unit, so we can\n                // pass the UTF16 string right through.\n                str += String.fromCharCode(codeUnit);\n            }\n            return str;\n        };\n        var stringToUTF16 = (str, outPtr, maxBytesToWrite)=>{\n            assert(outPtr % 2 == 0, 'Pointer passed to stringToUTF16 must be aligned to two bytes!');\n            assert(typeof maxBytesToWrite == 'number', 'stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');\n            // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\n            maxBytesToWrite ??= 0x7FFFFFFF;\n            if (maxBytesToWrite < 2) return 0;\n            maxBytesToWrite -= 2; // Null terminator.\n            var startPtr = outPtr;\n            var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;\n            for(var i = 0; i < numCharsToWrite; ++i){\n                // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.\n                var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\n                HEAP16[outPtr >> 1] = codeUnit;\n                outPtr += 2;\n            }\n            // Null-terminate the pointer to the HEAP.\n            HEAP16[outPtr >> 1] = 0;\n            return outPtr - startPtr;\n        };\n        var lengthBytesUTF16 = (str)=>str.length * 2;\n        var UTF32ToString = (ptr, maxBytesToRead)=>{\n            assert(ptr % 4 == 0, 'Pointer passed to UTF32ToString must be aligned to four bytes!');\n            var str = '';\n            // If maxBytesToRead is not passed explicitly, it will be undefined, and this\n            // will always evaluate to true. This saves on code size.\n            for(var i = 0; !(i >= maxBytesToRead / 4); i++){\n                var utf32 = HEAP32[ptr + i * 4 >> 2];\n                if (!utf32) break;\n                str += String.fromCodePoint(utf32);\n            }\n            return str;\n        };\n        var stringToUTF32 = (str, outPtr, maxBytesToWrite)=>{\n            assert(outPtr % 4 == 0, 'Pointer passed to stringToUTF32 must be aligned to four bytes!');\n            assert(typeof maxBytesToWrite == 'number', 'stringToUTF32(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');\n            // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\n            maxBytesToWrite ??= 0x7FFFFFFF;\n            if (maxBytesToWrite < 4) return 0;\n            var startPtr = outPtr;\n            var endPtr = startPtr + maxBytesToWrite - 4;\n            for(var i = 0; i < str.length; ++i){\n                var codePoint = str.codePointAt(i);\n                // Gotcha: if codePoint is over 0xFFFF, it is represented as a surrogate pair in UTF-16.\n                // We need to manually skip over the second code unit for correct iteration.\n                if (codePoint > 0xFFFF) i++;\n                HEAP32[outPtr >> 2] = codePoint;\n                outPtr += 4;\n                if (outPtr + 4 > endPtr) break;\n            }\n            // Null-terminate the pointer to the HEAP.\n            HEAP32[outPtr >> 2] = 0;\n            return outPtr - startPtr;\n        };\n        var lengthBytesUTF32 = (str)=>{\n            var len = 0;\n            for(var i = 0; i < str.length; ++i){\n                var codePoint = str.codePointAt(i);\n                // Gotcha: if codePoint is over 0xFFFF, it is represented as a surrogate pair in UTF-16.\n                // We need to manually skip over the second code unit for correct iteration.\n                if (codePoint > 0xFFFF) i++;\n                len += 4;\n            }\n            return len;\n        };\n        var __embind_register_std_wstring = (rawType, charSize, name)=>{\n            name = AsciiToString(name);\n            var decodeString, encodeString, readCharAt, lengthBytesUTF;\n            if (charSize === 2) {\n                decodeString = UTF16ToString;\n                encodeString = stringToUTF16;\n                lengthBytesUTF = lengthBytesUTF16;\n                readCharAt = (pointer)=>HEAPU16[pointer >> 1];\n            } else if (charSize === 4) {\n                decodeString = UTF32ToString;\n                encodeString = stringToUTF32;\n                lengthBytesUTF = lengthBytesUTF32;\n                readCharAt = (pointer)=>HEAPU32[pointer >> 2];\n            }\n            registerType(rawType, {\n                name: name,\n                'fromWireType': (value)=>{\n                    // Code mostly taken from _embind_register_std_string fromWireType\n                    var length = HEAPU32[value >> 2];\n                    var str;\n                    var decodeStartPtr = value + 4;\n                    // Looping here to support possible embedded '0' bytes\n                    for(var i = 0; i <= length; ++i){\n                        var currentBytePtr = value + 4 + i * charSize;\n                        if (i == length || readCharAt(currentBytePtr) == 0) {\n                            var maxReadBytes = currentBytePtr - decodeStartPtr;\n                            var stringSegment = decodeString(decodeStartPtr, maxReadBytes);\n                            if (str === undefined) str = stringSegment;\n                            else {\n                                str += String.fromCharCode(0);\n                                str += stringSegment;\n                            }\n                            decodeStartPtr = currentBytePtr + charSize;\n                        }\n                    }\n                    _free(value);\n                    return str;\n                },\n                'toWireType': (destructors, value)=>{\n                    if (!(typeof value == 'string')) throwBindingError(`Cannot pass non-string to C++ string type ${name}`);\n                    // assumes POINTER_SIZE alignment\n                    var length = lengthBytesUTF(value);\n                    var ptr = _malloc(4 + length + charSize);\n                    HEAPU32[ptr >> 2] = length / charSize;\n                    encodeString(value, ptr + 4, length + charSize);\n                    if (destructors !== null) destructors.push(_free, ptr);\n                    return ptr;\n                },\n                argPackAdvance: GenericWireTypeSize,\n                'readValueFromPointer': readPointer,\n                destructorFunction (ptr) {\n                    _free(ptr);\n                }\n            });\n        };\n        var __embind_register_void = (rawType, name)=>{\n            name = AsciiToString(name);\n            registerType(rawType, {\n                isVoid: true,\n                name: name,\n                argPackAdvance: 0,\n                'fromWireType': ()=>undefined,\n                // TODO: assert if anything else is given?\n                'toWireType': (destructors, o)=>undefined\n            });\n        };\n        var requireRegisteredType = (rawType, humanName)=>{\n            var impl = registeredTypes[rawType];\n            if (undefined === impl) throwBindingError(`${humanName} has unknown type ${getTypeName(rawType)}`);\n            return impl;\n        };\n        var __emval_take_value = (type, arg)=>{\n            type = requireRegisteredType(type, '_emval_take_value');\n            var v = type['readValueFromPointer'](arg);\n            return Emval.toHandle(v);\n        };\n        var abortOnCannotGrowMemory = (requestedSize)=>{\n            abort(`Cannot enlarge memory arrays to size ${requestedSize} bytes (OOM). Either (1) compile with -sINITIAL_MEMORY=X with X higher than the current value ${HEAP8.length}, (2) compile with -sALLOW_MEMORY_GROWTH which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with -sABORTING_MALLOC=0`);\n        };\n        var _emscripten_resize_heap = (requestedSize)=>{\n            var oldSize = HEAPU8.length;\n            // With CAN_ADDRESS_2GB or MEMORY64, pointers are already unsigned.\n            requestedSize >>>= 0;\n            abortOnCannotGrowMemory(requestedSize);\n        };\n        var SYSCALLS = {\n            varargs: undefined,\n            getStr (ptr) {\n                var ret = UTF8ToString(ptr);\n                return ret;\n            }\n        };\n        var _fd_close = (fd)=>{\n            abort('fd_close called without SYSCALLS_REQUIRE_FILESYSTEM');\n        };\n        var INT53_MAX = 9007199254740992;\n        var INT53_MIN = -9007199254740992;\n        var bigintToI53Checked = (num)=>num < INT53_MIN || num > INT53_MAX ? NaN : Number(num);\n        function _fd_seek(fd, offset, whence, newOffset) {\n            offset = bigintToI53Checked(offset);\n            return 70;\n        }\n        var printCharBuffers = [\n            null,\n            [],\n            []\n        ];\n        var printChar = (stream, curr)=>{\n            var buffer = printCharBuffers[stream];\n            assert(buffer);\n            if (curr === 0 || curr === 10) {\n                (stream === 1 ? out : err)(UTF8ArrayToString(buffer));\n                buffer.length = 0;\n            } else buffer.push(curr);\n        };\n        var flush_NO_FILESYSTEM = ()=>{\n            // flush anything remaining in the buffers during shutdown\n            _fflush(0);\n            if (printCharBuffers[1].length) printChar(1, 10);\n            if (printCharBuffers[2].length) printChar(2, 10);\n        };\n        var _fd_write = (fd, iov, iovcnt, pnum)=>{\n            // hack to support printf in SYSCALLS_REQUIRE_FILESYSTEM=0\n            var num = 0;\n            for(var i = 0; i < iovcnt; i++){\n                var ptr = HEAPU32[iov >> 2];\n                var len = HEAPU32[iov + 4 >> 2];\n                iov += 8;\n                for(var j = 0; j < len; j++)printChar(fd, HEAPU8[ptr + j]);\n                num += len;\n            }\n            HEAPU32[pnum >> 2] = num;\n            return 0;\n        };\n        init_ClassHandle();\n        init_RegisteredPointer();\n        assert(emval_handles.length === 10);\n        // Begin ATMODULES hooks\n        if (Module['noExitRuntime']) noExitRuntime = Module['noExitRuntime'];\n        if (Module['print']) out = Module['print'];\n        if (Module['printErr']) err = Module['printErr'];\n        if (Module['wasmBinary']) wasmBinary = Module['wasmBinary'];\n        Module['FS_createDataFile'] = FS.createDataFile;\n        Module['FS_createPreloadedFile'] = FS.createPreloadedFile;\n        // End ATMODULES hooks\n        checkIncomingModuleAPI();\n        if (Module['arguments']) arguments_ = Module['arguments'];\n        if (Module['thisProgram']) thisProgram = Module['thisProgram'];\n        // Assertions on removed incoming Module JS APIs.\n        assert(typeof Module['memoryInitializerPrefixURL'] == 'undefined', 'Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead');\n        assert(typeof Module['pthreadMainPrefixURL'] == 'undefined', 'Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead');\n        assert(typeof Module['cdInitializerPrefixURL'] == 'undefined', 'Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead');\n        assert(typeof Module['filePackagePrefixURL'] == 'undefined', 'Module.filePackagePrefixURL option was removed, use Module.locateFile instead');\n        assert(typeof Module['read'] == 'undefined', 'Module.read option was removed');\n        assert(typeof Module['readAsync'] == 'undefined', 'Module.readAsync option was removed (modify readAsync in JS)');\n        assert(typeof Module['readBinary'] == 'undefined', 'Module.readBinary option was removed (modify readBinary in JS)');\n        assert(typeof Module['setWindowTitle'] == 'undefined', 'Module.setWindowTitle option was removed (modify emscripten_set_window_title in JS)');\n        assert(typeof Module['TOTAL_MEMORY'] == 'undefined', 'Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY');\n        assert(typeof Module['ENVIRONMENT'] == 'undefined', 'Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -sENVIRONMENT=web or -sENVIRONMENT=node)');\n        assert(typeof Module['STACK_SIZE'] == 'undefined', 'STACK_SIZE can no longer be set at runtime.  Use -sSTACK_SIZE at link time');\n        // If memory is defined in wasm, the user can't provide it, or set INITIAL_MEMORY\n        assert(typeof Module['wasmMemory'] == 'undefined', 'Use of `wasmMemory` detected.  Use -sIMPORTED_MEMORY to define wasmMemory externally');\n        assert(typeof Module['INITIAL_MEMORY'] == 'undefined', 'Detected runtime INITIAL_MEMORY setting.  Use -sIMPORTED_MEMORY to define wasmMemory dynamically');\n        // Begin runtime exports\n        var missingLibrarySymbols = [\n            'writeI53ToI64',\n            'writeI53ToI64Clamped',\n            'writeI53ToI64Signaling',\n            'writeI53ToU64Clamped',\n            'writeI53ToU64Signaling',\n            'readI53FromI64',\n            'readI53FromU64',\n            'convertI32PairToI53',\n            'convertI32PairToI53Checked',\n            'convertU32PairToI53',\n            'stackAlloc',\n            'getTempRet0',\n            'setTempRet0',\n            'zeroMemory',\n            'exitJS',\n            'getHeapMax',\n            'growMemory',\n            'withStackSave',\n            'strError',\n            'inetPton4',\n            'inetNtop4',\n            'inetPton6',\n            'inetNtop6',\n            'readSockaddr',\n            'writeSockaddr',\n            'emscriptenLog',\n            'readEmAsmArgs',\n            'jstoi_q',\n            'getExecutableName',\n            'autoResumeAudioContext',\n            'getDynCaller',\n            'dynCall',\n            'handleException',\n            'keepRuntimeAlive',\n            'runtimeKeepalivePush',\n            'runtimeKeepalivePop',\n            'callUserCallback',\n            'maybeExit',\n            'asmjsMangle',\n            'asyncLoad',\n            'alignMemory',\n            'mmapAlloc',\n            'HandleAllocator',\n            'getNativeTypeSize',\n            'getUniqueRunDependency',\n            'addOnInit',\n            'addOnPostCtor',\n            'addOnPreMain',\n            'addOnExit',\n            'STACK_SIZE',\n            'STACK_ALIGN',\n            'POINTER_SIZE',\n            'ASSERTIONS',\n            'ccall',\n            'cwrap',\n            'uleb128Encode',\n            'sigToWasmTypes',\n            'generateFuncType',\n            'convertJsFunctionToWasm',\n            'getEmptyTableSlot',\n            'updateTableMap',\n            'getFunctionAddress',\n            'addFunction',\n            'removeFunction',\n            'reallyNegative',\n            'unSign',\n            'strLen',\n            'reSign',\n            'formatString',\n            'intArrayFromString',\n            'intArrayToString',\n            'stringToAscii',\n            'stringToNewUTF8',\n            'stringToUTF8OnStack',\n            'writeArrayToMemory',\n            'registerKeyEventCallback',\n            'maybeCStringToJsString',\n            'findEventTarget',\n            'getBoundingClientRect',\n            'fillMouseEventData',\n            'registerMouseEventCallback',\n            'registerWheelEventCallback',\n            'registerUiEventCallback',\n            'registerFocusEventCallback',\n            'fillDeviceOrientationEventData',\n            'registerDeviceOrientationEventCallback',\n            'fillDeviceMotionEventData',\n            'registerDeviceMotionEventCallback',\n            'screenOrientation',\n            'fillOrientationChangeEventData',\n            'registerOrientationChangeEventCallback',\n            'fillFullscreenChangeEventData',\n            'registerFullscreenChangeEventCallback',\n            'JSEvents_requestFullscreen',\n            'JSEvents_resizeCanvasForFullscreen',\n            'registerRestoreOldStyle',\n            'hideEverythingExceptGivenElement',\n            'restoreHiddenElements',\n            'setLetterbox',\n            'softFullscreenResizeWebGLRenderTarget',\n            'doRequestFullscreen',\n            'fillPointerlockChangeEventData',\n            'registerPointerlockChangeEventCallback',\n            'registerPointerlockErrorEventCallback',\n            'requestPointerLock',\n            'fillVisibilityChangeEventData',\n            'registerVisibilityChangeEventCallback',\n            'registerTouchEventCallback',\n            'fillGamepadEventData',\n            'registerGamepadEventCallback',\n            'registerBeforeUnloadEventCallback',\n            'fillBatteryEventData',\n            'battery',\n            'registerBatteryEventCallback',\n            'setCanvasElementSize',\n            'getCanvasElementSize',\n            'jsStackTrace',\n            'getCallstack',\n            'convertPCtoSourceLocation',\n            'getEnvStrings',\n            'checkWasiClock',\n            'wasiRightsToMuslOFlags',\n            'wasiOFlagsToMuslOFlags',\n            'initRandomFill',\n            'randomFill',\n            'safeSetTimeout',\n            'setImmediateWrapped',\n            'safeRequestAnimationFrame',\n            'clearImmediateWrapped',\n            'registerPostMainLoop',\n            'registerPreMainLoop',\n            'getPromise',\n            'makePromise',\n            'idsToPromises',\n            'makePromiseCallback',\n            'findMatchingCatch',\n            'Browser_asyncPrepareDataCounter',\n            'isLeapYear',\n            'ydayFromDate',\n            'arraySum',\n            'addDays',\n            'getSocketFromFD',\n            'getSocketAddress',\n            'FS_createPreloadedFile',\n            'FS_modeStringToFlags',\n            'FS_getMode',\n            'FS_stdin_getChar',\n            'FS_mkdirTree',\n            '_setNetworkCallback',\n            'heapObjectForWebGLType',\n            'toTypedArrayIndex',\n            'webgl_enable_ANGLE_instanced_arrays',\n            'webgl_enable_OES_vertex_array_object',\n            'webgl_enable_WEBGL_draw_buffers',\n            'webgl_enable_WEBGL_multi_draw',\n            'webgl_enable_EXT_polygon_offset_clamp',\n            'webgl_enable_EXT_clip_control',\n            'webgl_enable_WEBGL_polygon_mode',\n            'emscriptenWebGLGet',\n            'computeUnpackAlignedImageSize',\n            'colorChannelsInGlTextureFormat',\n            'emscriptenWebGLGetTexPixelData',\n            'emscriptenWebGLGetUniform',\n            'webglGetUniformLocation',\n            'webglPrepareUniformLocationsBeforeFirstUse',\n            'webglGetLeftBracePos',\n            'emscriptenWebGLGetVertexAttrib',\n            '__glGetActiveAttribOrUniform',\n            'writeGLArray',\n            'registerWebGlEventCallback',\n            'runAndAbortIfError',\n            'ALLOC_NORMAL',\n            'ALLOC_STACK',\n            'allocate',\n            'writeStringToMemory',\n            'writeAsciiToMemory',\n            'demangle',\n            'stackTrace',\n            'getFunctionArgsName',\n            'createJsInvokerSignature',\n            'PureVirtualError',\n            'registerInheritedInstance',\n            'unregisterInheritedInstance',\n            'getInheritedInstanceCount',\n            'getLiveInheritedInstances',\n            'enumReadValueFromPointer',\n            'setDelayFunction',\n            'validateThis',\n            'count_emval_handles',\n            'getStringOrSymbol',\n            'emval_get_global',\n            'emval_returnValue',\n            'emval_lookupTypes',\n            'emval_addMethodCaller'\n        ];\n        missingLibrarySymbols.forEach(missingLibrarySymbol);\n        var unexportedSymbols = [\n            'run',\n            'addRunDependency',\n            'removeRunDependency',\n            'out',\n            'err',\n            'callMain',\n            'abort',\n            'wasmMemory',\n            'wasmExports',\n            'HEAPF32',\n            'HEAPF64',\n            'HEAP8',\n            'HEAPU8',\n            'HEAP16',\n            'HEAPU16',\n            'HEAP32',\n            'HEAPU32',\n            'HEAP64',\n            'HEAPU64',\n            'writeStackCookie',\n            'checkStackCookie',\n            'INT53_MAX',\n            'INT53_MIN',\n            'bigintToI53Checked',\n            'stackSave',\n            'stackRestore',\n            'ptrToString',\n            'abortOnCannotGrowMemory',\n            'ENV',\n            'ERRNO_CODES',\n            'DNS',\n            'Protocols',\n            'Sockets',\n            'timers',\n            'warnOnce',\n            'readEmAsmArgsArray',\n            'wasmTable',\n            'noExitRuntime',\n            'addOnPreRun',\n            'addOnPostRun',\n            'freeTableIndexes',\n            'functionsInTableMap',\n            'setValue',\n            'getValue',\n            'PATH',\n            'PATH_FS',\n            'UTF8Decoder',\n            'UTF8ArrayToString',\n            'UTF8ToString',\n            'stringToUTF8Array',\n            'stringToUTF8',\n            'lengthBytesUTF8',\n            'AsciiToString',\n            'UTF16Decoder',\n            'UTF16ToString',\n            'stringToUTF16',\n            'lengthBytesUTF16',\n            'UTF32ToString',\n            'stringToUTF32',\n            'lengthBytesUTF32',\n            'JSEvents',\n            'specialHTMLTargets',\n            'findCanvasEventTarget',\n            'currentFullscreenStrategy',\n            'restoreOldWindowedStyle',\n            'UNWIND_CACHE',\n            'ExitStatus',\n            'flush_NO_FILESYSTEM',\n            'emSetImmediate',\n            'emClearImmediate_deps',\n            'emClearImmediate',\n            'promiseMap',\n            'uncaughtExceptionCount',\n            'exceptionLast',\n            'exceptionCaught',\n            'ExceptionInfo',\n            'Browser',\n            'requestFullscreen',\n            'requestFullScreen',\n            'setCanvasSize',\n            'getUserMedia',\n            'createContext',\n            'getPreloadedImageData__data',\n            'wget',\n            'MONTH_DAYS_REGULAR',\n            'MONTH_DAYS_LEAP',\n            'MONTH_DAYS_REGULAR_CUMULATIVE',\n            'MONTH_DAYS_LEAP_CUMULATIVE',\n            'SYSCALLS',\n            'preloadPlugins',\n            'FS_stdin_getChar_buffer',\n            'FS_unlink',\n            'FS_createPath',\n            'FS_createDevice',\n            'FS_readFile',\n            'FS',\n            'FS_root',\n            'FS_mounts',\n            'FS_devices',\n            'FS_streams',\n            'FS_nextInode',\n            'FS_nameTable',\n            'FS_currentPath',\n            'FS_initialized',\n            'FS_ignorePermissions',\n            'FS_filesystems',\n            'FS_syncFSRequests',\n            'FS_readFiles',\n            'FS_lookupPath',\n            'FS_getPath',\n            'FS_hashName',\n            'FS_hashAddNode',\n            'FS_hashRemoveNode',\n            'FS_lookupNode',\n            'FS_createNode',\n            'FS_destroyNode',\n            'FS_isRoot',\n            'FS_isMountpoint',\n            'FS_isFile',\n            'FS_isDir',\n            'FS_isLink',\n            'FS_isChrdev',\n            'FS_isBlkdev',\n            'FS_isFIFO',\n            'FS_isSocket',\n            'FS_flagsToPermissionString',\n            'FS_nodePermissions',\n            'FS_mayLookup',\n            'FS_mayCreate',\n            'FS_mayDelete',\n            'FS_mayOpen',\n            'FS_checkOpExists',\n            'FS_nextfd',\n            'FS_getStreamChecked',\n            'FS_getStream',\n            'FS_createStream',\n            'FS_closeStream',\n            'FS_dupStream',\n            'FS_doSetAttr',\n            'FS_chrdev_stream_ops',\n            'FS_major',\n            'FS_minor',\n            'FS_makedev',\n            'FS_registerDevice',\n            'FS_getDevice',\n            'FS_getMounts',\n            'FS_syncfs',\n            'FS_mount',\n            'FS_unmount',\n            'FS_lookup',\n            'FS_mknod',\n            'FS_statfs',\n            'FS_statfsStream',\n            'FS_statfsNode',\n            'FS_create',\n            'FS_mkdir',\n            'FS_mkdev',\n            'FS_symlink',\n            'FS_rename',\n            'FS_rmdir',\n            'FS_readdir',\n            'FS_readlink',\n            'FS_stat',\n            'FS_fstat',\n            'FS_lstat',\n            'FS_doChmod',\n            'FS_chmod',\n            'FS_lchmod',\n            'FS_fchmod',\n            'FS_doChown',\n            'FS_chown',\n            'FS_lchown',\n            'FS_fchown',\n            'FS_doTruncate',\n            'FS_truncate',\n            'FS_ftruncate',\n            'FS_utime',\n            'FS_open',\n            'FS_close',\n            'FS_isClosed',\n            'FS_llseek',\n            'FS_read',\n            'FS_write',\n            'FS_mmap',\n            'FS_msync',\n            'FS_ioctl',\n            'FS_writeFile',\n            'FS_cwd',\n            'FS_chdir',\n            'FS_createDefaultDirectories',\n            'FS_createDefaultDevices',\n            'FS_createSpecialDirectories',\n            'FS_createStandardStreams',\n            'FS_staticInit',\n            'FS_init',\n            'FS_quit',\n            'FS_findObject',\n            'FS_analyzePath',\n            'FS_createFile',\n            'FS_createDataFile',\n            'FS_forceLoadFile',\n            'FS_createLazyFile',\n            'FS_absolutePath',\n            'FS_createFolder',\n            'FS_createLink',\n            'FS_joinPath',\n            'FS_mmapAlloc',\n            'FS_standardizePath',\n            'MEMFS',\n            'TTY',\n            'PIPEFS',\n            'SOCKFS',\n            'tempFixedLengthArray',\n            'miniTempWebGLFloatBuffers',\n            'miniTempWebGLIntBuffers',\n            'GL',\n            'AL',\n            'GLUT',\n            'EGL',\n            'GLEW',\n            'IDBStore',\n            'SDL',\n            'SDL_gfx',\n            'allocateUTF8',\n            'allocateUTF8OnStack',\n            'print',\n            'printErr',\n            'jstoi_s',\n            'InternalError',\n            'BindingError',\n            'throwInternalError',\n            'throwBindingError',\n            'registeredTypes',\n            'awaitingDependencies',\n            'typeDependencies',\n            'tupleRegistrations',\n            'structRegistrations',\n            'sharedRegisterType',\n            'whenDependentTypesAreResolved',\n            'getTypeName',\n            'getFunctionName',\n            'heap32VectorToArray',\n            'requireRegisteredType',\n            'usesDestructorStack',\n            'checkArgCount',\n            'getRequiredArgCount',\n            'createJsInvoker',\n            'UnboundTypeError',\n            'GenericWireTypeSize',\n            'EmValType',\n            'EmValOptionalType',\n            'throwUnboundTypeError',\n            'ensureOverloadTable',\n            'exposePublicSymbol',\n            'replacePublicSymbol',\n            'createNamedFunction',\n            'embindRepr',\n            'registeredInstances',\n            'getBasestPointer',\n            'getInheritedInstance',\n            'registeredPointers',\n            'registerType',\n            'integerReadValueFromPointer',\n            'floatReadValueFromPointer',\n            'assertIntegerRange',\n            'readPointer',\n            'runDestructors',\n            'craftInvokerFunction',\n            'embind__requireFunction',\n            'genericPointerToWireType',\n            'constNoSmartPtrRawPointerToWireType',\n            'nonConstNoSmartPtrRawPointerToWireType',\n            'init_RegisteredPointer',\n            'RegisteredPointer',\n            'RegisteredPointer_fromWireType',\n            'runDestructor',\n            'releaseClassHandle',\n            'finalizationRegistry',\n            'detachFinalizer_deps',\n            'detachFinalizer',\n            'attachFinalizer',\n            'makeClassHandle',\n            'init_ClassHandle',\n            'ClassHandle',\n            'throwInstanceAlreadyDeleted',\n            'deletionQueue',\n            'flushPendingDeletes',\n            'delayFunction',\n            'RegisteredClass',\n            'shallowCopyInternalPointer',\n            'downcastPointer',\n            'upcastPointer',\n            'char_0',\n            'char_9',\n            'makeLegalFunctionName',\n            'emval_freelist',\n            'emval_handles',\n            'emval_symbols',\n            'Emval',\n            'emval_methodCallers'\n        ];\n        unexportedSymbols.forEach(unexportedRuntimeSymbol);\n        // End runtime exports\n        // Begin JS library exports\n        // End JS library exports\n        // end include: postlibrary.js\n        function checkIncomingModuleAPI() {\n            ignoredModuleProp('fetchSettings');\n        }\n        // Imports from the Wasm binary.\n        var ___getTypeName = makeInvalidEarlyAccess('___getTypeName');\n        var _fflush = makeInvalidEarlyAccess('_fflush');\n        var _emscripten_stack_get_end = makeInvalidEarlyAccess('_emscripten_stack_get_end');\n        var _emscripten_stack_get_base = makeInvalidEarlyAccess('_emscripten_stack_get_base');\n        var _malloc = makeInvalidEarlyAccess('_malloc');\n        var _strerror = makeInvalidEarlyAccess('_strerror');\n        var _free = makeInvalidEarlyAccess('_free');\n        var _emscripten_stack_init = makeInvalidEarlyAccess('_emscripten_stack_init');\n        var _emscripten_stack_get_free = makeInvalidEarlyAccess('_emscripten_stack_get_free');\n        var __emscripten_stack_restore = makeInvalidEarlyAccess('__emscripten_stack_restore');\n        var __emscripten_stack_alloc = makeInvalidEarlyAccess('__emscripten_stack_alloc');\n        var _emscripten_stack_get_current = makeInvalidEarlyAccess('_emscripten_stack_get_current');\n        function assignWasmExports(wasmExports) {\n            ___getTypeName = createExportWrapper('__getTypeName', 1);\n            _fflush = createExportWrapper('fflush', 1);\n            _emscripten_stack_get_end = wasmExports['emscripten_stack_get_end'];\n            _emscripten_stack_get_base = wasmExports['emscripten_stack_get_base'];\n            _malloc = createExportWrapper('malloc', 1);\n            _strerror = createExportWrapper('strerror', 1);\n            _free = createExportWrapper('free', 1);\n            _emscripten_stack_init = wasmExports['emscripten_stack_init'];\n            _emscripten_stack_get_free = wasmExports['emscripten_stack_get_free'];\n            __emscripten_stack_restore = wasmExports['_emscripten_stack_restore'];\n            __emscripten_stack_alloc = wasmExports['_emscripten_stack_alloc'];\n            _emscripten_stack_get_current = wasmExports['emscripten_stack_get_current'];\n        }\n        var wasmImports = {\n            /** @export */ __cxa_throw: ___cxa_throw,\n            /** @export */ _abort_js: __abort_js,\n            /** @export */ _embind_register_bigint: __embind_register_bigint,\n            /** @export */ _embind_register_bool: __embind_register_bool,\n            /** @export */ _embind_register_class: __embind_register_class,\n            /** @export */ _embind_register_class_constructor: __embind_register_class_constructor,\n            /** @export */ _embind_register_class_function: __embind_register_class_function,\n            /** @export */ _embind_register_emval: __embind_register_emval,\n            /** @export */ _embind_register_float: __embind_register_float,\n            /** @export */ _embind_register_function: __embind_register_function,\n            /** @export */ _embind_register_integer: __embind_register_integer,\n            /** @export */ _embind_register_memory_view: __embind_register_memory_view,\n            /** @export */ _embind_register_optional: __embind_register_optional,\n            /** @export */ _embind_register_std_string: __embind_register_std_string,\n            /** @export */ _embind_register_std_wstring: __embind_register_std_wstring,\n            /** @export */ _embind_register_void: __embind_register_void,\n            /** @export */ _emval_decref: __emval_decref,\n            /** @export */ _emval_take_value: __emval_take_value,\n            /** @export */ emscripten_resize_heap: _emscripten_resize_heap,\n            /** @export */ fd_close: _fd_close,\n            /** @export */ fd_seek: _fd_seek,\n            /** @export */ fd_write: _fd_write\n        };\n        var wasmExports = await createWasm();\n        // include: postamble.js\n        // === Auto-generated postamble setup entry stuff ===\n        var calledRun;\n        function stackCheckInit() {\n            // This is normally called automatically during __wasm_call_ctors but need to\n            // get these values before even running any of the ctors so we call it redundantly\n            // here.\n            _emscripten_stack_init();\n            // TODO(sbc): Move writeStackCookie to native to to avoid this.\n            writeStackCookie();\n        }\n        function run() {\n            if (runDependencies > 0) {\n                dependenciesFulfilled = run;\n                return;\n            }\n            stackCheckInit();\n            preRun();\n            // a preRun added a dependency, run will be called later\n            if (runDependencies > 0) {\n                dependenciesFulfilled = run;\n                return;\n            }\n            function doRun() {\n                // run may have just been called through dependencies being fulfilled just in this very frame,\n                // or while the async setStatus time below was happening\n                assert(!calledRun);\n                calledRun = true;\n                Module['calledRun'] = true;\n                if (ABORT) return;\n                initRuntime();\n                readyPromiseResolve?.(Module);\n                Module['onRuntimeInitialized']?.();\n                consumedModuleProp('onRuntimeInitialized');\n                assert(!Module['_main'], 'compiled without a main, but one is present. if you added it from JS, use Module[\"onRuntimeInitialized\"]');\n                postRun();\n            }\n            if (Module['setStatus']) {\n                Module['setStatus']('Running...');\n                setTimeout(()=>{\n                    setTimeout(()=>Module['setStatus'](''), 1);\n                    doRun();\n                }, 1);\n            } else doRun();\n            checkStackCookie();\n        }\n        function checkUnflushedContent() {\n            // Compiler settings do not allow exiting the runtime, so flushing\n            // the streams is not possible. but in ASSERTIONS mode we check\n            // if there was something to flush, and if so tell the user they\n            // should request that the runtime be exitable.\n            // Normally we would not even include flush() at all, but in ASSERTIONS\n            // builds we do so just for this check, and here we see if there is any\n            // content to flush, that is, we check if there would have been\n            // something a non-ASSERTIONS build would have not seen.\n            // How we flush the streams depends on whether we are in SYSCALLS_REQUIRE_FILESYSTEM=0\n            // mode (which has its own special function for this; otherwise, all\n            // the code is inside libc)\n            var oldOut = out;\n            var oldErr = err;\n            var has = false;\n            out = err = (x)=>{\n                has = true;\n            };\n            try {\n                flush_NO_FILESYSTEM();\n            } catch (e) {}\n            out = oldOut;\n            err = oldErr;\n            if (has) {\n                warnOnce('stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the Emscripten FAQ), or make sure to emit a newline when you printf etc.');\n                warnOnce('(this may also be due to not including full filesystem support - try building with -sFORCE_FILESYSTEM)');\n            }\n        }\n        function preInit() {\n            if (Module['preInit']) {\n                if (typeof Module['preInit'] == 'function') Module['preInit'] = [\n                    Module['preInit']\n                ];\n                while(Module['preInit'].length > 0)Module['preInit'].shift()();\n            }\n            consumedModuleProp('preInit');\n        }\n        preInit();\n        run();\n        // end include: postamble.js\n        // include: postamble_modularize.js\n        // In MODULARIZE mode we wrap the generated code in a factory function\n        // and return either the Module itself, or a promise of the module.\n        //\n        // We assign to the `moduleRtn` global here and configure closure to see\n        // this as and extern so it won't get minified.\n        if (runtimeInitialized) moduleRtn = Module;\n        else // Set up the promise that indicates the Module is initialized\n        moduleRtn = new Promise((resolve, reject)=>{\n            readyPromiseResolve = resolve;\n            readyPromiseReject = reject;\n        });\n        // Assertion for attempting to access module properties on the incoming\n        // moduleArg.  In the past we used this object as the prototype of the module\n        // and assigned properties to it, but now we return a distinct object.  This\n        // keeps the instance private until it is ready (i.e the promise has been\n        // resolved).\n        for (const prop of Object.keys(Module))if (!(prop in moduleArg)) Object.defineProperty(moduleArg, prop, {\n            configurable: true,\n            get () {\n                abort(`Access to module property ('${prop}') is no longer possible via the module constructor argument; Instead, use the result of the module constructor.`);\n            }\n        });\n        // end include: postamble_modularize.js\n        return moduleRtn;\n    };\n})();\nmodule.exports = $60a79d9be2fe59af$var$createModule;\n// This default export looks redundant, but it allows TS to import this\n// commonjs style module.\nmodule.exports.default = $60a79d9be2fe59af$var$createModule;\n\n});\n\n\n\nparcelRequire(\"lQc82\");\n})();\n//# sourceMappingURL=wasm-worker.2ad872a2.js.map\n","import createModule from '../../public/optimizer.js'\n\nconst modulePromise = createModule();\n\nasync function optimize(config) {\n    const Module = await modulePromise;\n    const serialized = Module.optimize(\n        config.groups, config.people.length, config.roles.length, config.tables, config.weeks\n    );\n\n    const result = {person: [], group: [], role: [], table: [], week: []};\n\n    for(let week = 0; week < config.weeks; week++) {\n        for(let group = 0; group < config.groups; group++) {\n            const offset = week * config.groups + group;\n            const person = config.people[serialized.get(offset)];\n            const roleRaw = serialized.get(offset + 1);\n            const role = roleRaw < config.roles.length ? config.roles[roleRaw] : '';\n            const table = serialized.get(offset + 2)+1\n\n            result.person.push(person);\n            result.week.push(week);\n            result.group.push(group);\n            result.role.push(role);\n            result.table.push(table);\n\n        }\n    }\n    \n    self.postMessage({\n        operation: 'result',\n        payload: result\n    });\n}\n\nself.onmessage = async (e) => {\n    self.postMessage({\n        operation: 'log',\n        payload: 'This is a test'\n    });\n    switch(e.data.operation) {\n        case 'optimize': {\n            optimize(e.data.payload);\n            break;\n        }\n        default: {\n            break;\n        }\n    }\n};","var createModule = (() => {\n  var _scriptName = typeof document != 'undefined' ? document.currentScript?.src : undefined;\n  return (\nasync function(moduleArg = {}) {\n  var moduleRtn;\n\n// include: shell.js\n// The Module object: Our interface to the outside world. We import\n// and export values on it. There are various ways Module can be used:\n// 1. Not defined. We create it here\n// 2. A function parameter, function(moduleArg) => Promise<Module>\n// 3. pre-run appended it, var Module = {}; ..generated code..\n// 4. External script tag defines var Module.\n// We need to check if Module already exists (e.g. case 3 above).\n// Substitution will be replaced with actual code on later stage of the build,\n// this way Closure Compiler will not mangle it (e.g. case 4. above).\n// Note that if you want to run closure, and also to use Module\n// after the generated code, you will need to define   var Module = {};\n// before the code. Then that object will be used in the code, and you\n// can continue to use Module afterwards as well.\nvar Module = moduleArg;\n\n// Determine the runtime environment we are in. You can customize this by\n// setting the ENVIRONMENT setting at compile time (see settings.js).\n\nvar ENVIRONMENT_IS_WEB = true;\nvar ENVIRONMENT_IS_WORKER = false;\nvar ENVIRONMENT_IS_NODE = false;\nvar ENVIRONMENT_IS_SHELL = false;\n\n// --pre-jses are emitted after the Module integration code, so that they can\n// refer to Module (if they choose; they can also define Module)\n\n\nvar arguments_ = [];\nvar thisProgram = './this.program';\nvar quit_ = (status, toThrow) => {\n  throw toThrow;\n};\n\n// `/` should be present at the end if `scriptDirectory` is not empty\nvar scriptDirectory = '';\nfunction locateFile(path) {\n  if (Module['locateFile']) {\n    return Module['locateFile'](path, scriptDirectory);\n  }\n  return scriptDirectory + path;\n}\n\n// Hooks that are implemented differently in different runtime environments.\nvar readAsync, readBinary;\n\nif (ENVIRONMENT_IS_SHELL) {\n\n  const isNode = typeof process == 'object' && process.versions?.node && process.type != 'renderer';\n  if (isNode || typeof window == 'object' || typeof WorkerGlobalScope != 'undefined') throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');\n\n} else\n\n// Note that this includes Node.js workers when relevant (pthreads is enabled).\n// Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and\n// ENVIRONMENT_IS_NODE.\nif (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n  try {\n    scriptDirectory = new URL('.', _scriptName).href; // includes trailing slash\n  } catch {\n    // Must be a `blob:` or `data:` URL (e.g. `blob:http://site.com/etc/etc`), we cannot\n    // infer anything from them.\n  }\n\n  if (!(typeof window == 'object' || typeof WorkerGlobalScope != 'undefined')) throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');\n\n  {\n// include: web_or_worker_shell_read.js\nreadAsync = async (url) => {\n    assert(!isFileURI(url), \"readAsync does not work with file:// URLs\");\n    var response = await fetch(url, { credentials: 'same-origin' });\n    if (response.ok) {\n      return response.arrayBuffer();\n    }\n    throw new Error(response.status + ' : ' + response.url);\n  };\n// end include: web_or_worker_shell_read.js\n  }\n} else\n{\n  throw new Error('environment detection error');\n}\n\nvar out = console.log.bind(console);\nvar err = console.error.bind(console);\n\nvar IDBFS = 'IDBFS is no longer included by default; build with -lidbfs.js';\nvar PROXYFS = 'PROXYFS is no longer included by default; build with -lproxyfs.js';\nvar WORKERFS = 'WORKERFS is no longer included by default; build with -lworkerfs.js';\nvar FETCHFS = 'FETCHFS is no longer included by default; build with -lfetchfs.js';\nvar ICASEFS = 'ICASEFS is no longer included by default; build with -licasefs.js';\nvar JSFILEFS = 'JSFILEFS is no longer included by default; build with -ljsfilefs.js';\nvar OPFS = 'OPFS is no longer included by default; build with -lopfs.js';\n\nvar NODEFS = 'NODEFS is no longer included by default; build with -lnodefs.js';\n\n// perform assertions in shell.js after we set up out() and err(), as otherwise\n// if an assertion fails it cannot print the message\n\nassert(!ENVIRONMENT_IS_WORKER, 'worker environment detected but not enabled at build time.  Add `worker` to `-sENVIRONMENT` to enable.');\n\nassert(!ENVIRONMENT_IS_NODE, 'node environment detected but not enabled at build time.  Add `node` to `-sENVIRONMENT` to enable.');\n\nassert(!ENVIRONMENT_IS_SHELL, 'shell environment detected but not enabled at build time.  Add `shell` to `-sENVIRONMENT` to enable.');\n\n// end include: shell.js\n\n// include: preamble.js\n// === Preamble library stuff ===\n\n// Documentation for the public APIs defined in this file must be updated in:\n//    site/source/docs/api_reference/preamble.js.rst\n// A prebuilt local version of the documentation is available at:\n//    site/build/text/docs/api_reference/preamble.js.txt\n// You can also build docs locally as HTML or other formats in site/\n// An online HTML version (which may be of a different version of Emscripten)\n//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html\n\nvar wasmBinary;\n\nif (typeof WebAssembly != 'object') {\n  err('no native wasm support detected');\n}\n\n// Wasm globals\n\n//========================================\n// Runtime essentials\n//========================================\n\n// whether we are quitting the application. no code should run after this.\n// set in exit() and abort()\nvar ABORT = false;\n\n// set by exit() and abort().  Passed to 'onExit' handler.\n// NOTE: This is also used as the process return code code in shell environments\n// but only when noExitRuntime is false.\nvar EXITSTATUS;\n\n// In STRICT mode, we only define assert() when ASSERTIONS is set.  i.e. we\n// don't define it at all in release modes.  This matches the behaviour of\n// MINIMAL_RUNTIME.\n// TODO(sbc): Make this the default even without STRICT enabled.\n/** @type {function(*, string=)} */\nfunction assert(condition, text) {\n  if (!condition) {\n    abort('Assertion failed' + (text ? ': ' + text : ''));\n  }\n}\n\n// We used to include malloc/free by default in the past. Show a helpful error in\n// builds with assertions.\n\n/**\n * Indicates whether filename is delivered via file protocol (as opposed to http/https)\n * @noinline\n */\nvar isFileURI = (filename) => filename.startsWith('file://');\n\n// include: runtime_common.js\n// include: runtime_stack_check.js\n// Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode.\nfunction writeStackCookie() {\n  var max = _emscripten_stack_get_end();\n  assert((max & 3) == 0);\n  // If the stack ends at address zero we write our cookies 4 bytes into the\n  // stack.  This prevents interference with SAFE_HEAP and ASAN which also\n  // monitor writes to address zero.\n  if (max == 0) {\n    max += 4;\n  }\n  // The stack grow downwards towards _emscripten_stack_get_end.\n  // We write cookies to the final two words in the stack and detect if they are\n  // ever overwritten.\n  HEAPU32[((max)>>2)] = 0x02135467;\n  HEAPU32[(((max)+(4))>>2)] = 0x89BACDFE;\n  // Also test the global address 0 for integrity.\n  HEAPU32[((0)>>2)] = 1668509029;\n}\n\nfunction checkStackCookie() {\n  if (ABORT) return;\n  var max = _emscripten_stack_get_end();\n  // See writeStackCookie().\n  if (max == 0) {\n    max += 4;\n  }\n  var cookie1 = HEAPU32[((max)>>2)];\n  var cookie2 = HEAPU32[(((max)+(4))>>2)];\n  if (cookie1 != 0x02135467 || cookie2 != 0x89BACDFE) {\n    abort(`Stack overflow! Stack cookie has been overwritten at ${ptrToString(max)}, expected hex dwords 0x89BACDFE and 0x2135467, but received ${ptrToString(cookie2)} ${ptrToString(cookie1)}`);\n  }\n  // Also test the global address 0 for integrity.\n  if (HEAPU32[((0)>>2)] != 0x63736d65 /* 'emsc' */) {\n    abort('Runtime error: The application has corrupted its heap memory area (address zero)!');\n  }\n}\n// end include: runtime_stack_check.js\n// include: runtime_exceptions.js\n// end include: runtime_exceptions.js\n// include: runtime_debug.js\nvar runtimeDebug = true; // Switch to false at runtime to disable logging at the right times\n\n// Used by XXXXX_DEBUG settings to output debug messages.\nfunction dbg(...args) {\n  if (!runtimeDebug && typeof runtimeDebug != 'undefined') return;\n  // TODO(sbc): Make this configurable somehow.  Its not always convenient for\n  // logging to show up as warnings.\n  console.warn(...args);\n}\n\n// Endianness check\n(() => {\n  var h16 = new Int16Array(1);\n  var h8 = new Int8Array(h16.buffer);\n  h16[0] = 0x6373;\n  if (h8[0] !== 0x73 || h8[1] !== 0x63) throw 'Runtime error: expected the system to be little-endian! (Run with -sSUPPORT_BIG_ENDIAN to bypass)';\n})();\n\nfunction consumedModuleProp(prop) {\n  if (!Object.getOwnPropertyDescriptor(Module, prop)) {\n    Object.defineProperty(Module, prop, {\n      configurable: true,\n      set() {\n        abort(`Attempt to set \\`Module.${prop}\\` after it has already been processed.  This can happen, for example, when code is injected via '--post-js' rather than '--pre-js'`);\n\n      }\n    });\n  }\n}\n\nfunction makeInvalidEarlyAccess(name) {\n  return () => assert(false, `call to '${name}' via reference taken before Wasm module initialization`);\n\n}\n\nfunction ignoredModuleProp(prop) {\n  if (Object.getOwnPropertyDescriptor(Module, prop)) {\n    abort(`\\`Module.${prop}\\` was supplied but \\`${prop}\\` not included in INCOMING_MODULE_JS_API`);\n  }\n}\n\n// forcing the filesystem exports a few things by default\nfunction isExportedByForceFilesystem(name) {\n  return name === 'FS_createPath' ||\n         name === 'FS_createDataFile' ||\n         name === 'FS_createPreloadedFile' ||\n         name === 'FS_unlink' ||\n         name === 'addRunDependency' ||\n         // The old FS has some functionality that WasmFS lacks.\n         name === 'FS_createLazyFile' ||\n         name === 'FS_createDevice' ||\n         name === 'removeRunDependency';\n}\n\n/**\n * Intercept access to a global symbol.  This enables us to give informative\n * warnings/errors when folks attempt to use symbols they did not include in\n * their build, or no symbols that no longer exist.\n */\nfunction hookGlobalSymbolAccess(sym, func) {\n  // In MODULARIZE mode the generated code runs inside a function scope and not\n  // the global scope, and JavaScript does not provide access to function scopes\n  // so we cannot dynamically modify the scrope using `defineProperty` in this\n  // case.\n  //\n  // In this mode we simply ignore requests for `hookGlobalSymbolAccess`. Since\n  // this is a debug-only feature, skipping it is not major issue.\n}\n\nfunction missingGlobal(sym, msg) {\n  hookGlobalSymbolAccess(sym, () => {\n    warnOnce(`\\`${sym}\\` is not longer defined by emscripten. ${msg}`);\n  });\n}\n\nmissingGlobal('buffer', 'Please use HEAP8.buffer or wasmMemory.buffer');\nmissingGlobal('asm', 'Please use wasmExports instead');\n\nfunction missingLibrarySymbol(sym) {\n  hookGlobalSymbolAccess(sym, () => {\n    // Can't `abort()` here because it would break code that does runtime\n    // checks.  e.g. `if (typeof SDL === 'undefined')`.\n    var msg = `\\`${sym}\\` is a library symbol and not included by default; add it to your library.js __deps or to DEFAULT_LIBRARY_FUNCS_TO_INCLUDE on the command line`;\n    // DEFAULT_LIBRARY_FUNCS_TO_INCLUDE requires the name as it appears in\n    // library.js, which means $name for a JS name with no prefix, or name\n    // for a JS name like _name.\n    var librarySymbol = sym;\n    if (!librarySymbol.startsWith('_')) {\n      librarySymbol = '$' + sym;\n    }\n    msg += ` (e.g. -sDEFAULT_LIBRARY_FUNCS_TO_INCLUDE='${librarySymbol}')`;\n    if (isExportedByForceFilesystem(sym)) {\n      msg += '. Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you';\n    }\n    warnOnce(msg);\n  });\n\n  // Any symbol that is not included from the JS library is also (by definition)\n  // not exported on the Module object.\n  unexportedRuntimeSymbol(sym);\n}\n\nfunction unexportedRuntimeSymbol(sym) {\n  if (!Object.getOwnPropertyDescriptor(Module, sym)) {\n    Object.defineProperty(Module, sym, {\n      configurable: true,\n      get() {\n        var msg = `'${sym}' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the Emscripten FAQ)`;\n        if (isExportedByForceFilesystem(sym)) {\n          msg += '. Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you';\n        }\n        abort(msg);\n      }\n    });\n  }\n}\n\n// end include: runtime_debug.js\nvar readyPromiseResolve, readyPromiseReject;\n\n// Memory management\n\nvar wasmMemory;\n\nvar\n/** @type {!Int8Array} */\n  HEAP8,\n/** @type {!Uint8Array} */\n  HEAPU8,\n/** @type {!Int16Array} */\n  HEAP16,\n/** @type {!Uint16Array} */\n  HEAPU16,\n/** @type {!Int32Array} */\n  HEAP32,\n/** @type {!Uint32Array} */\n  HEAPU32,\n/** @type {!Float32Array} */\n  HEAPF32,\n/** @type {!Float64Array} */\n  HEAPF64;\n\n// BigInt64Array type is not correctly defined in closure\nvar\n/** not-@type {!BigInt64Array} */\n  HEAP64,\n/* BigUint64Array type is not correctly defined in closure\n/** not-@type {!BigUint64Array} */\n  HEAPU64;\n\nvar runtimeInitialized = false;\n\n\n\nfunction updateMemoryViews() {\n  var b = wasmMemory.buffer;\n  HEAP8 = new Int8Array(b);\n  HEAP16 = new Int16Array(b);\n  HEAPU8 = new Uint8Array(b);\n  HEAPU16 = new Uint16Array(b);\n  HEAP32 = new Int32Array(b);\n  HEAPU32 = new Uint32Array(b);\n  HEAPF32 = new Float32Array(b);\n  HEAPF64 = new Float64Array(b);\n  HEAP64 = new BigInt64Array(b);\n  HEAPU64 = new BigUint64Array(b);\n}\n\n// include: memoryprofiler.js\n// end include: memoryprofiler.js\n// end include: runtime_common.js\nassert(typeof Int32Array != 'undefined' && typeof Float64Array !== 'undefined' && Int32Array.prototype.subarray != undefined && Int32Array.prototype.set != undefined,\n       'JS engine does not provide full typed array support');\n\nfunction preRun() {\n  if (Module['preRun']) {\n    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];\n    while (Module['preRun'].length) {\n      addOnPreRun(Module['preRun'].shift());\n    }\n  }\n  consumedModuleProp('preRun');\n  // Begin ATPRERUNS hooks\n  callRuntimeCallbacks(onPreRuns);\n  // End ATPRERUNS hooks\n}\n\nfunction initRuntime() {\n  assert(!runtimeInitialized);\n  runtimeInitialized = true;\n\n  checkStackCookie();\n\n  // No ATINITS hooks\n\n  wasmExports['__wasm_call_ctors']();\n\n  // No ATPOSTCTORS hooks\n}\n\nfunction postRun() {\n  checkStackCookie();\n   // PThreads reuse the runtime from the main thread.\n\n  if (Module['postRun']) {\n    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];\n    while (Module['postRun'].length) {\n      addOnPostRun(Module['postRun'].shift());\n    }\n  }\n  consumedModuleProp('postRun');\n\n  // Begin ATPOSTRUNS hooks\n  callRuntimeCallbacks(onPostRuns);\n  // End ATPOSTRUNS hooks\n}\n\n// A counter of dependencies for calling run(). If we need to\n// do asynchronous work before running, increment this and\n// decrement it. Incrementing must happen in a place like\n// Module.preRun (used by emcc to add file preloading).\n// Note that you can add dependencies in preRun, even though\n// it happens right before run - run will be postponed until\n// the dependencies are met.\nvar runDependencies = 0;\nvar dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled\nvar runDependencyTracking = {};\nvar runDependencyWatcher = null;\n\nfunction addRunDependency(id) {\n  runDependencies++;\n\n  Module['monitorRunDependencies']?.(runDependencies);\n\n  if (id) {\n    assert(!runDependencyTracking[id]);\n    runDependencyTracking[id] = 1;\n    if (runDependencyWatcher === null && typeof setInterval != 'undefined') {\n      // Check for missing dependencies every few seconds\n      runDependencyWatcher = setInterval(() => {\n        if (ABORT) {\n          clearInterval(runDependencyWatcher);\n          runDependencyWatcher = null;\n          return;\n        }\n        var shown = false;\n        for (var dep in runDependencyTracking) {\n          if (!shown) {\n            shown = true;\n            err('still waiting on run dependencies:');\n          }\n          err(`dependency: ${dep}`);\n        }\n        if (shown) {\n          err('(end of list)');\n        }\n      }, 10000);\n    }\n  } else {\n    err('warning: run dependency added without ID');\n  }\n}\n\nfunction removeRunDependency(id) {\n  runDependencies--;\n\n  Module['monitorRunDependencies']?.(runDependencies);\n\n  if (id) {\n    assert(runDependencyTracking[id]);\n    delete runDependencyTracking[id];\n  } else {\n    err('warning: run dependency removed without ID');\n  }\n  if (runDependencies == 0) {\n    if (runDependencyWatcher !== null) {\n      clearInterval(runDependencyWatcher);\n      runDependencyWatcher = null;\n    }\n    if (dependenciesFulfilled) {\n      var callback = dependenciesFulfilled;\n      dependenciesFulfilled = null;\n      callback(); // can add another dependenciesFulfilled\n    }\n  }\n}\n\n/** @param {string|number=} what */\nfunction abort(what) {\n  Module['onAbort']?.(what);\n\n  what = 'Aborted(' + what + ')';\n  // TODO(sbc): Should we remove printing and leave it up to whoever\n  // catches the exception?\n  err(what);\n\n  ABORT = true;\n\n  // Use a wasm runtime error, because a JS error might be seen as a foreign\n  // exception, which means we'd run destructors on it. We need the error to\n  // simply make the program stop.\n  // FIXME This approach does not work in Wasm EH because it currently does not assume\n  // all RuntimeErrors are from traps; it decides whether a RuntimeError is from\n  // a trap or not based on a hidden field within the object. So at the moment\n  // we don't have a way of throwing a wasm trap from JS. TODO Make a JS API that\n  // allows this in the wasm spec.\n\n  // Suppress closure compiler warning here. Closure compiler's builtin extern\n  // definition for WebAssembly.RuntimeError claims it takes no arguments even\n  // though it can.\n  // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure gets fixed.\n  /** @suppress {checkTypes} */\n  var e = new WebAssembly.RuntimeError(what);\n\n  readyPromiseReject?.(e);\n  // Throw the error whether or not MODULARIZE is set because abort is used\n  // in code paths apart from instantiation where an exception is expected\n  // to be thrown when abort is called.\n  throw e;\n}\n\n// show errors on likely calls to FS when it was not included\nvar FS = {\n  error() {\n    abort('Filesystem support (FS) was not included. The problem is that you are using files from JS, but files were not used from C/C++, so filesystem support was not auto-included. You can force-include filesystem support with -sFORCE_FILESYSTEM');\n  },\n  init() { FS.error() },\n  createDataFile() { FS.error() },\n  createPreloadedFile() { FS.error() },\n  createLazyFile() { FS.error() },\n  open() { FS.error() },\n  mkdev() { FS.error() },\n  registerDevice() { FS.error() },\n  analyzePath() { FS.error() },\n\n  ErrnoError() { FS.error() },\n};\n\n\nfunction createExportWrapper(name, nargs) {\n  return (...args) => {\n    assert(runtimeInitialized, `native function \\`${name}\\` called before runtime initialization`);\n    var f = wasmExports[name];\n    assert(f, `exported native function \\`${name}\\` not found`);\n    // Only assert for too many arguments. Too few can be valid since the missing arguments will be zero filled.\n    assert(args.length <= nargs, `native function \\`${name}\\` called with ${args.length} args but expects ${nargs}`);\n    return f(...args);\n  };\n}\n\nvar wasmBinaryFile;\n\nfunction findWasmBinary() {\n    return locateFile('optimizer.wasm');\n}\n\nfunction getBinarySync(file) {\n  if (file == wasmBinaryFile && wasmBinary) {\n    return new Uint8Array(wasmBinary);\n  }\n  if (readBinary) {\n    return readBinary(file);\n  }\n  throw 'both async and sync fetching of the wasm failed';\n}\n\nasync function getWasmBinary(binaryFile) {\n  // If we don't have the binary yet, load it asynchronously using readAsync.\n  if (!wasmBinary) {\n    // Fetch the binary using readAsync\n    try {\n      var response = await readAsync(binaryFile);\n      return new Uint8Array(response);\n    } catch {\n      // Fall back to getBinarySync below;\n    }\n  }\n\n  // Otherwise, getBinarySync should be able to get it synchronously\n  return getBinarySync(binaryFile);\n}\n\nasync function instantiateArrayBuffer(binaryFile, imports) {\n  try {\n    var binary = await getWasmBinary(binaryFile);\n    var instance = await WebAssembly.instantiate(binary, imports);\n    return instance;\n  } catch (reason) {\n    err(`failed to asynchronously prepare wasm: ${reason}`);\n\n    // Warn on some common problems.\n    if (isFileURI(wasmBinaryFile)) {\n      err(`warning: Loading from a file URI (${wasmBinaryFile}) is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing`);\n    }\n    abort(reason);\n  }\n}\n\nasync function instantiateAsync(binary, binaryFile, imports) {\n  if (!binary && typeof WebAssembly.instantiateStreaming == 'function'\n     ) {\n    try {\n      var response = fetch(binaryFile, { credentials: 'same-origin' });\n      var instantiationResult = await WebAssembly.instantiateStreaming(response, imports);\n      return instantiationResult;\n    } catch (reason) {\n      // We expect the most common failure cause to be a bad MIME type for the binary,\n      // in which case falling back to ArrayBuffer instantiation should work.\n      err(`wasm streaming compile failed: ${reason}`);\n      err('falling back to ArrayBuffer instantiation');\n      // fall back of instantiateArrayBuffer below\n    };\n  }\n  return instantiateArrayBuffer(binaryFile, imports);\n}\n\nfunction getWasmImports() {\n  // prepare imports\n  return {\n    'env': wasmImports,\n    'wasi_snapshot_preview1': wasmImports,\n  }\n}\n\n// Create the wasm instance.\n// Receives the wasm imports, returns the exports.\nasync function createWasm() {\n  // Load the wasm module and create an instance of using native support in the JS engine.\n  // handle a generated wasm instance, receiving its exports and\n  // performing other necessary setup\n  /** @param {WebAssembly.Module=} module*/\n  function receiveInstance(instance, module) {\n    wasmExports = instance.exports;\n\n    \n\n    wasmMemory = wasmExports['memory'];\n    \n    assert(wasmMemory, 'memory not found in wasm exports');\n    updateMemoryViews();\n\n    wasmTable = wasmExports['__indirect_function_table'];\n    \n    assert(wasmTable, 'table not found in wasm exports');\n\n    assignWasmExports(wasmExports);\n    removeRunDependency('wasm-instantiate');\n    return wasmExports;\n  }\n  // wait for the pthread pool (if any)\n  addRunDependency('wasm-instantiate');\n\n  // Prefer streaming instantiation if available.\n  // Async compilation can be confusing when an error on the page overwrites Module\n  // (for example, if the order of elements is wrong, and the one defining Module is\n  // later), so we save Module and check it later.\n  var trueModule = Module;\n  function receiveInstantiationResult(result) {\n    // 'result' is a ResultObject object which has both the module and instance.\n    // receiveInstance() will swap in the exports (to Module.asm) so they can be called\n    assert(Module === trueModule, 'the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?');\n    trueModule = null;\n    // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.\n    // When the regression is fixed, can restore the above PTHREADS-enabled path.\n    return receiveInstance(result['instance']);\n  }\n\n  var info = getWasmImports();\n\n  // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback\n  // to manually instantiate the Wasm module themselves. This allows pages to\n  // run the instantiation parallel to any other async startup actions they are\n  // performing.\n  // Also pthreads and wasm workers initialize the wasm instance through this\n  // path.\n  if (Module['instantiateWasm']) {\n    return new Promise((resolve, reject) => {\n      try {\n        Module['instantiateWasm'](info, (mod, inst) => {\n          resolve(receiveInstance(mod, inst));\n        });\n      } catch(e) {\n        err(`Module.instantiateWasm callback failed with error: ${e}`);\n        reject(e);\n      }\n    });\n  }\n\n  wasmBinaryFile ??= findWasmBinary();\n  var result = await instantiateAsync(wasmBinary, wasmBinaryFile, info);\n  var exports = receiveInstantiationResult(result);\n  return exports;\n}\n\n// end include: preamble.js\n\n// Begin JS library code\n\n\n  class ExitStatus {\n      name = 'ExitStatus';\n      constructor(status) {\n        this.message = `Program terminated with exit(${status})`;\n        this.status = status;\n      }\n    }\n\n  var callRuntimeCallbacks = (callbacks) => {\n      while (callbacks.length > 0) {\n        // Pass the module as the first argument.\n        callbacks.shift()(Module);\n      }\n    };\n  var onPostRuns = [];\n  var addOnPostRun = (cb) => onPostRuns.push(cb);\n\n  var onPreRuns = [];\n  var addOnPreRun = (cb) => onPreRuns.push(cb);\n\n\n  \n    /**\n     * @param {number} ptr\n     * @param {string} type\n     */\n  function getValue(ptr, type = 'i8') {\n    if (type.endsWith('*')) type = '*';\n    switch (type) {\n      case 'i1': return HEAP8[ptr];\n      case 'i8': return HEAP8[ptr];\n      case 'i16': return HEAP16[((ptr)>>1)];\n      case 'i32': return HEAP32[((ptr)>>2)];\n      case 'i64': return HEAP64[((ptr)>>3)];\n      case 'float': return HEAPF32[((ptr)>>2)];\n      case 'double': return HEAPF64[((ptr)>>3)];\n      case '*': return HEAPU32[((ptr)>>2)];\n      default: abort(`invalid type for getValue: ${type}`);\n    }\n  }\n\n  var noExitRuntime = true;\n\n  var ptrToString = (ptr) => {\n      assert(typeof ptr === 'number');\n      // With CAN_ADDRESS_2GB or MEMORY64, pointers are already unsigned.\n      ptr >>>= 0;\n      return '0x' + ptr.toString(16).padStart(8, '0');\n    };\n\n  \n    /**\n     * @param {number} ptr\n     * @param {number} value\n     * @param {string} type\n     */\n  function setValue(ptr, value, type = 'i8') {\n    if (type.endsWith('*')) type = '*';\n    switch (type) {\n      case 'i1': HEAP8[ptr] = value; break;\n      case 'i8': HEAP8[ptr] = value; break;\n      case 'i16': HEAP16[((ptr)>>1)] = value; break;\n      case 'i32': HEAP32[((ptr)>>2)] = value; break;\n      case 'i64': HEAP64[((ptr)>>3)] = BigInt(value); break;\n      case 'float': HEAPF32[((ptr)>>2)] = value; break;\n      case 'double': HEAPF64[((ptr)>>3)] = value; break;\n      case '*': HEAPU32[((ptr)>>2)] = value; break;\n      default: abort(`invalid type for setValue: ${type}`);\n    }\n  }\n\n  var stackRestore = (val) => __emscripten_stack_restore(val);\n\n  var stackSave = () => _emscripten_stack_get_current();\n\n  var warnOnce = (text) => {\n      warnOnce.shown ||= {};\n      if (!warnOnce.shown[text]) {\n        warnOnce.shown[text] = 1;\n        err(text);\n      }\n    };\n\n  class ExceptionInfo {\n      // excPtr - Thrown object pointer to wrap. Metadata pointer is calculated from it.\n      constructor(excPtr) {\n        this.excPtr = excPtr;\n        this.ptr = excPtr - 24;\n      }\n  \n      set_type(type) {\n        HEAPU32[(((this.ptr)+(4))>>2)] = type;\n      }\n  \n      get_type() {\n        return HEAPU32[(((this.ptr)+(4))>>2)];\n      }\n  \n      set_destructor(destructor) {\n        HEAPU32[(((this.ptr)+(8))>>2)] = destructor;\n      }\n  \n      get_destructor() {\n        return HEAPU32[(((this.ptr)+(8))>>2)];\n      }\n  \n      set_caught(caught) {\n        caught = caught ? 1 : 0;\n        HEAP8[(this.ptr)+(12)] = caught;\n      }\n  \n      get_caught() {\n        return HEAP8[(this.ptr)+(12)] != 0;\n      }\n  \n      set_rethrown(rethrown) {\n        rethrown = rethrown ? 1 : 0;\n        HEAP8[(this.ptr)+(13)] = rethrown;\n      }\n  \n      get_rethrown() {\n        return HEAP8[(this.ptr)+(13)] != 0;\n      }\n  \n      // Initialize native structure fields. Should be called once after allocated.\n      init(type, destructor) {\n        this.set_adjusted_ptr(0);\n        this.set_type(type);\n        this.set_destructor(destructor);\n      }\n  \n      set_adjusted_ptr(adjustedPtr) {\n        HEAPU32[(((this.ptr)+(16))>>2)] = adjustedPtr;\n      }\n  \n      get_adjusted_ptr() {\n        return HEAPU32[(((this.ptr)+(16))>>2)];\n      }\n    }\n  \n  var exceptionLast = 0;\n  \n  var uncaughtExceptionCount = 0;\n  var ___cxa_throw = (ptr, type, destructor) => {\n      var info = new ExceptionInfo(ptr);\n      // Initialize ExceptionInfo content after it was allocated in __cxa_allocate_exception.\n      info.init(type, destructor);\n      exceptionLast = ptr;\n      uncaughtExceptionCount++;\n      assert(false, 'Exception thrown, but exception catching is not enabled. Compile with -sNO_DISABLE_EXCEPTION_CATCHING or -sEXCEPTION_CATCHING_ALLOWED=[..] to catch.');\n    };\n\n  var __abort_js = () =>\n      abort('native code called abort()');\n\n  var AsciiToString = (ptr) => {\n      var str = '';\n      while (1) {\n        var ch = HEAPU8[ptr++];\n        if (!ch) return str;\n        str += String.fromCharCode(ch);\n      }\n    };\n  \n  var awaitingDependencies = {\n  };\n  \n  var registeredTypes = {\n  };\n  \n  var typeDependencies = {\n  };\n  \n  var BindingError =  class BindingError extends Error { constructor(message) { super(message); this.name = 'BindingError'; }};\n  var throwBindingError = (message) => { throw new BindingError(message); };\n  /** @param {Object=} options */\n  function sharedRegisterType(rawType, registeredInstance, options = {}) {\n      var name = registeredInstance.name;\n      if (!rawType) {\n        throwBindingError(`type \"${name}\" must have a positive integer typeid pointer`);\n      }\n      if (registeredTypes.hasOwnProperty(rawType)) {\n        if (options.ignoreDuplicateRegistrations) {\n          return;\n        } else {\n          throwBindingError(`Cannot register type '${name}' twice`);\n        }\n      }\n  \n      registeredTypes[rawType] = registeredInstance;\n      delete typeDependencies[rawType];\n  \n      if (awaitingDependencies.hasOwnProperty(rawType)) {\n        var callbacks = awaitingDependencies[rawType];\n        delete awaitingDependencies[rawType];\n        callbacks.forEach((cb) => cb());\n      }\n    }\n  /** @param {Object=} options */\n  function registerType(rawType, registeredInstance, options = {}) {\n      if (registeredInstance.argPackAdvance === undefined) {\n        throw new TypeError('registerType registeredInstance requires argPackAdvance');\n      }\n      return sharedRegisterType(rawType, registeredInstance, options);\n    }\n  \n  var integerReadValueFromPointer = (name, width, signed) => {\n      // integers are quite common, so generate very specialized functions\n      switch (width) {\n        case 1: return signed ?\n          (pointer) => HEAP8[pointer] :\n          (pointer) => HEAPU8[pointer];\n        case 2: return signed ?\n          (pointer) => HEAP16[((pointer)>>1)] :\n          (pointer) => HEAPU16[((pointer)>>1)]\n        case 4: return signed ?\n          (pointer) => HEAP32[((pointer)>>2)] :\n          (pointer) => HEAPU32[((pointer)>>2)]\n        case 8: return signed ?\n          (pointer) => HEAP64[((pointer)>>3)] :\n          (pointer) => HEAPU64[((pointer)>>3)]\n        default:\n          throw new TypeError(`invalid integer width (${width}): ${name}`);\n      }\n    };\n  \n  var embindRepr = (v) => {\n      if (v === null) {\n          return 'null';\n      }\n      var t = typeof v;\n      if (t === 'object' || t === 'array' || t === 'function') {\n          return v.toString();\n      } else {\n          return '' + v;\n      }\n    };\n  \n  var assertIntegerRange = (typeName, value, minRange, maxRange) => {\n      if (value < minRange || value > maxRange) {\n        throw new TypeError(`Passing a number \"${embindRepr(value)}\" from JS side to C/C++ side to an argument of type \"${typeName}\", which is outside the valid range [${minRange}, ${maxRange}]!`);\n      }\n    };\n  /** @suppress {globalThis} */\n  var __embind_register_bigint = (primitiveType, name, size, minRange, maxRange) => {\n      name = AsciiToString(name);\n  \n      const isUnsignedType = minRange === 0n;\n  \n      let fromWireType = (value) => value;\n      if (isUnsignedType) {\n        // uint64 get converted to int64 in ABI, fix them up like we do for 32-bit integers.\n        const bitSize = size * 8;\n        fromWireType = (value) => {\n          return BigInt.asUintN(bitSize, value);\n        }\n        maxRange = fromWireType(maxRange);\n      }\n  \n      registerType(primitiveType, {\n        name,\n        'fromWireType': fromWireType,\n        'toWireType': (destructors, value) => {\n          if (typeof value == \"number\") {\n            value = BigInt(value);\n          }\n          else if (typeof value != \"bigint\") {\n            throw new TypeError(`Cannot convert \"${embindRepr(value)}\" to ${this.name}`);\n          }\n          assertIntegerRange(name, value, minRange, maxRange);\n          return value;\n        },\n        argPackAdvance: GenericWireTypeSize,\n        'readValueFromPointer': integerReadValueFromPointer(name, size, !isUnsignedType),\n        destructorFunction: null, // This type does not need a destructor\n      });\n    };\n\n  \n  \n  var GenericWireTypeSize = 8;\n  /** @suppress {globalThis} */\n  var __embind_register_bool = (rawType, name, trueValue, falseValue) => {\n      name = AsciiToString(name);\n      registerType(rawType, {\n        name,\n        'fromWireType': function(wt) {\n          // ambiguous emscripten ABI: sometimes return values are\n          // true or false, and sometimes integers (0 or 1)\n          return !!wt;\n        },\n        'toWireType': function(destructors, o) {\n          return o ? trueValue : falseValue;\n        },\n        argPackAdvance: GenericWireTypeSize,\n        'readValueFromPointer': function(pointer) {\n          return this['fromWireType'](HEAPU8[pointer]);\n        },\n        destructorFunction: null, // This type does not need a destructor\n      });\n    };\n\n  \n  \n  var shallowCopyInternalPointer = (o) => {\n      return {\n        count: o.count,\n        deleteScheduled: o.deleteScheduled,\n        preservePointerOnDelete: o.preservePointerOnDelete,\n        ptr: o.ptr,\n        ptrType: o.ptrType,\n        smartPtr: o.smartPtr,\n        smartPtrType: o.smartPtrType,\n      };\n    };\n  \n  var throwInstanceAlreadyDeleted = (obj) => {\n      function getInstanceTypeName(handle) {\n        return handle.$$.ptrType.registeredClass.name;\n      }\n      throwBindingError(getInstanceTypeName(obj) + ' instance already deleted');\n    };\n  \n  var finalizationRegistry = false;\n  \n  var detachFinalizer = (handle) => {};\n  \n  var runDestructor = ($$) => {\n      if ($$.smartPtr) {\n        $$.smartPtrType.rawDestructor($$.smartPtr);\n      } else {\n        $$.ptrType.registeredClass.rawDestructor($$.ptr);\n      }\n    };\n  var releaseClassHandle = ($$) => {\n      $$.count.value -= 1;\n      var toDelete = 0 === $$.count.value;\n      if (toDelete) {\n        runDestructor($$);\n      }\n    };\n  \n  var downcastPointer = (ptr, ptrClass, desiredClass) => {\n      if (ptrClass === desiredClass) {\n        return ptr;\n      }\n      if (undefined === desiredClass.baseClass) {\n        return null; // no conversion\n      }\n  \n      var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);\n      if (rv === null) {\n        return null;\n      }\n      return desiredClass.downcast(rv);\n    };\n  \n  var registeredPointers = {\n  };\n  \n  var registeredInstances = {\n  };\n  \n  var getBasestPointer = (class_, ptr) => {\n      if (ptr === undefined) {\n          throwBindingError('ptr should not be undefined');\n      }\n      while (class_.baseClass) {\n          ptr = class_.upcast(ptr);\n          class_ = class_.baseClass;\n      }\n      return ptr;\n    };\n  var getInheritedInstance = (class_, ptr) => {\n      ptr = getBasestPointer(class_, ptr);\n      return registeredInstances[ptr];\n    };\n  \n  var InternalError =  class InternalError extends Error { constructor(message) { super(message); this.name = 'InternalError'; }};\n  var throwInternalError = (message) => { throw new InternalError(message); };\n  \n  var makeClassHandle = (prototype, record) => {\n      if (!record.ptrType || !record.ptr) {\n        throwInternalError('makeClassHandle requires ptr and ptrType');\n      }\n      var hasSmartPtrType = !!record.smartPtrType;\n      var hasSmartPtr = !!record.smartPtr;\n      if (hasSmartPtrType !== hasSmartPtr) {\n        throwInternalError('Both smartPtrType and smartPtr must be specified');\n      }\n      record.count = { value: 1 };\n      return attachFinalizer(Object.create(prototype, {\n        $$: {\n          value: record,\n          writable: true,\n        },\n      }));\n    };\n  /** @suppress {globalThis} */\n  function RegisteredPointer_fromWireType(ptr) {\n      // ptr is a raw pointer (or a raw smartpointer)\n  \n      // rawPointer is a maybe-null raw pointer\n      var rawPointer = this.getPointee(ptr);\n      if (!rawPointer) {\n        this.destructor(ptr);\n        return null;\n      }\n  \n      var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);\n      if (undefined !== registeredInstance) {\n        // JS object has been neutered, time to repopulate it\n        if (0 === registeredInstance.$$.count.value) {\n          registeredInstance.$$.ptr = rawPointer;\n          registeredInstance.$$.smartPtr = ptr;\n          return registeredInstance['clone']();\n        } else {\n          // else, just increment reference count on existing object\n          // it already has a reference to the smart pointer\n          var rv = registeredInstance['clone']();\n          this.destructor(ptr);\n          return rv;\n        }\n      }\n  \n      function makeDefaultHandle() {\n        if (this.isSmartPointer) {\n          return makeClassHandle(this.registeredClass.instancePrototype, {\n            ptrType: this.pointeeType,\n            ptr: rawPointer,\n            smartPtrType: this,\n            smartPtr: ptr,\n          });\n        } else {\n          return makeClassHandle(this.registeredClass.instancePrototype, {\n            ptrType: this,\n            ptr,\n          });\n        }\n      }\n  \n      var actualType = this.registeredClass.getActualType(rawPointer);\n      var registeredPointerRecord = registeredPointers[actualType];\n      if (!registeredPointerRecord) {\n        return makeDefaultHandle.call(this);\n      }\n  \n      var toType;\n      if (this.isConst) {\n        toType = registeredPointerRecord.constPointerType;\n      } else {\n        toType = registeredPointerRecord.pointerType;\n      }\n      var dp = downcastPointer(\n          rawPointer,\n          this.registeredClass,\n          toType.registeredClass);\n      if (dp === null) {\n        return makeDefaultHandle.call(this);\n      }\n      if (this.isSmartPointer) {\n        return makeClassHandle(toType.registeredClass.instancePrototype, {\n          ptrType: toType,\n          ptr: dp,\n          smartPtrType: this,\n          smartPtr: ptr,\n        });\n      } else {\n        return makeClassHandle(toType.registeredClass.instancePrototype, {\n          ptrType: toType,\n          ptr: dp,\n        });\n      }\n    }\n  var attachFinalizer = (handle) => {\n      if ('undefined' === typeof FinalizationRegistry) {\n        attachFinalizer = (handle) => handle;\n        return handle;\n      }\n      // If the running environment has a FinalizationRegistry (see\n      // https://github.com/tc39/proposal-weakrefs), then attach finalizers\n      // for class handles.  We check for the presence of FinalizationRegistry\n      // at run-time, not build-time.\n      finalizationRegistry = new FinalizationRegistry((info) => {\n        console.warn(info.leakWarning);\n        releaseClassHandle(info.$$);\n      });\n      attachFinalizer = (handle) => {\n        var $$ = handle.$$;\n        var hasSmartPtr = !!$$.smartPtr;\n        if (hasSmartPtr) {\n          // We should not call the destructor on raw pointers in case other code expects the pointee to live\n          var info = { $$: $$ };\n          // Create a warning as an Error instance in advance so that we can store\n          // the current stacktrace and point to it when / if a leak is detected.\n          // This is more useful than the empty stacktrace of `FinalizationRegistry`\n          // callback.\n          var cls = $$.ptrType.registeredClass;\n          var err = new Error(`Embind found a leaked C++ instance ${cls.name} <${ptrToString($$.ptr)}>.\\n` +\n          \"We'll free it automatically in this case, but this functionality is not reliable across various environments.\\n\" +\n          \"Make sure to invoke .delete() manually once you're done with the instance instead.\\n\" +\n          \"Originally allocated\"); // `.stack` will add \"at ...\" after this sentence\n          if ('captureStackTrace' in Error) {\n            Error.captureStackTrace(err, RegisteredPointer_fromWireType);\n          }\n          info.leakWarning = err.stack.replace(/^Error: /, '');\n          finalizationRegistry.register(handle, info, handle);\n        }\n        return handle;\n      };\n      detachFinalizer = (handle) => finalizationRegistry.unregister(handle);\n      return attachFinalizer(handle);\n    };\n  \n  \n  \n  \n  var deletionQueue = [];\n  var flushPendingDeletes = () => {\n      while (deletionQueue.length) {\n        var obj = deletionQueue.pop();\n        obj.$$.deleteScheduled = false;\n        obj['delete']();\n      }\n    };\n  \n  var delayFunction;\n  var init_ClassHandle = () => {\n      let proto = ClassHandle.prototype;\n  \n      Object.assign(proto, {\n        \"isAliasOf\"(other) {\n          if (!(this instanceof ClassHandle)) {\n            return false;\n          }\n          if (!(other instanceof ClassHandle)) {\n            return false;\n          }\n  \n          var leftClass = this.$$.ptrType.registeredClass;\n          var left = this.$$.ptr;\n          other.$$ = /** @type {Object} */ (other.$$);\n          var rightClass = other.$$.ptrType.registeredClass;\n          var right = other.$$.ptr;\n  \n          while (leftClass.baseClass) {\n            left = leftClass.upcast(left);\n            leftClass = leftClass.baseClass;\n          }\n  \n          while (rightClass.baseClass) {\n            right = rightClass.upcast(right);\n            rightClass = rightClass.baseClass;\n          }\n  \n          return leftClass === rightClass && left === right;\n        },\n  \n        \"clone\"() {\n          if (!this.$$.ptr) {\n            throwInstanceAlreadyDeleted(this);\n          }\n  \n          if (this.$$.preservePointerOnDelete) {\n            this.$$.count.value += 1;\n            return this;\n          } else {\n            var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), {\n              $$: {\n                value: shallowCopyInternalPointer(this.$$),\n              }\n            }));\n  \n            clone.$$.count.value += 1;\n            clone.$$.deleteScheduled = false;\n            return clone;\n          }\n        },\n  \n        \"delete\"() {\n          if (!this.$$.ptr) {\n            throwInstanceAlreadyDeleted(this);\n          }\n  \n          if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {\n            throwBindingError('Object already scheduled for deletion');\n          }\n  \n          detachFinalizer(this);\n          releaseClassHandle(this.$$);\n  \n          if (!this.$$.preservePointerOnDelete) {\n            this.$$.smartPtr = undefined;\n            this.$$.ptr = undefined;\n          }\n        },\n  \n        \"isDeleted\"() {\n          return !this.$$.ptr;\n        },\n  \n        \"deleteLater\"() {\n          if (!this.$$.ptr) {\n            throwInstanceAlreadyDeleted(this);\n          }\n          if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {\n            throwBindingError('Object already scheduled for deletion');\n          }\n          deletionQueue.push(this);\n          if (deletionQueue.length === 1 && delayFunction) {\n            delayFunction(flushPendingDeletes);\n          }\n          this.$$.deleteScheduled = true;\n          return this;\n        },\n      });\n  \n      // Support `using ...` from https://github.com/tc39/proposal-explicit-resource-management.\n      const symbolDispose = Symbol.dispose;\n      if (symbolDispose) {\n        proto[symbolDispose] = proto['delete'];\n      }\n    };\n  /** @constructor */\n  function ClassHandle() {\n    }\n  \n  var createNamedFunction = (name, func) => Object.defineProperty(func, 'name', { value: name });\n  \n  \n  var ensureOverloadTable = (proto, methodName, humanName) => {\n      if (undefined === proto[methodName].overloadTable) {\n        var prevFunc = proto[methodName];\n        // Inject an overload resolver function that routes to the appropriate overload based on the number of arguments.\n        proto[methodName] = function(...args) {\n          // TODO This check can be removed in -O3 level \"unsafe\" optimizations.\n          if (!proto[methodName].overloadTable.hasOwnProperty(args.length)) {\n            throwBindingError(`Function '${humanName}' called with an invalid number of arguments (${args.length}) - expects one of (${proto[methodName].overloadTable})!`);\n          }\n          return proto[methodName].overloadTable[args.length].apply(this, args);\n        };\n        // Move the previous function into the overload table.\n        proto[methodName].overloadTable = [];\n        proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;\n      }\n    };\n  \n  /** @param {number=} numArguments */\n  var exposePublicSymbol = (name, value, numArguments) => {\n      if (Module.hasOwnProperty(name)) {\n        if (undefined === numArguments || (undefined !== Module[name].overloadTable && undefined !== Module[name].overloadTable[numArguments])) {\n          throwBindingError(`Cannot register public name '${name}' twice`);\n        }\n  \n        // We are exposing a function with the same name as an existing function. Create an overload table and a function selector\n        // that routes between the two.\n        ensureOverloadTable(Module, name, name);\n        if (Module[name].overloadTable.hasOwnProperty(numArguments)) {\n          throwBindingError(`Cannot register multiple overloads of a function with the same number of arguments (${numArguments})!`);\n        }\n        // Add the new function into the overload table.\n        Module[name].overloadTable[numArguments] = value;\n      } else {\n        Module[name] = value;\n        Module[name].argCount = numArguments;\n      }\n    };\n  \n  var char_0 = 48;\n  \n  var char_9 = 57;\n  var makeLegalFunctionName = (name) => {\n      assert(typeof name === 'string');\n      name = name.replace(/[^a-zA-Z0-9_]/g, '$');\n      var f = name.charCodeAt(0);\n      if (f >= char_0 && f <= char_9) {\n        return `_${name}`;\n      }\n      return name;\n    };\n  \n  \n  /** @constructor */\n  function RegisteredClass(name,\n                               constructor,\n                               instancePrototype,\n                               rawDestructor,\n                               baseClass,\n                               getActualType,\n                               upcast,\n                               downcast) {\n      this.name = name;\n      this.constructor = constructor;\n      this.instancePrototype = instancePrototype;\n      this.rawDestructor = rawDestructor;\n      this.baseClass = baseClass;\n      this.getActualType = getActualType;\n      this.upcast = upcast;\n      this.downcast = downcast;\n      this.pureVirtualFunctions = [];\n    }\n  \n  \n  var upcastPointer = (ptr, ptrClass, desiredClass) => {\n      while (ptrClass !== desiredClass) {\n        if (!ptrClass.upcast) {\n          throwBindingError(`Expected null or instance of ${desiredClass.name}, got an instance of ${ptrClass.name}`);\n        }\n        ptr = ptrClass.upcast(ptr);\n        ptrClass = ptrClass.baseClass;\n      }\n      return ptr;\n    };\n  \n  /** @suppress {globalThis} */\n  function constNoSmartPtrRawPointerToWireType(destructors, handle) {\n      if (handle === null) {\n        if (this.isReference) {\n          throwBindingError(`null is not a valid ${this.name}`);\n        }\n        return 0;\n      }\n  \n      if (!handle.$$) {\n        throwBindingError(`Cannot pass \"${embindRepr(handle)}\" as a ${this.name}`);\n      }\n      if (!handle.$$.ptr) {\n        throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);\n      }\n      var handleClass = handle.$$.ptrType.registeredClass;\n      var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n      return ptr;\n    }\n  \n  \n  /** @suppress {globalThis} */\n  function genericPointerToWireType(destructors, handle) {\n      var ptr;\n      if (handle === null) {\n        if (this.isReference) {\n          throwBindingError(`null is not a valid ${this.name}`);\n        }\n  \n        if (this.isSmartPointer) {\n          ptr = this.rawConstructor();\n          if (destructors !== null) {\n            destructors.push(this.rawDestructor, ptr);\n          }\n          return ptr;\n        } else {\n          return 0;\n        }\n      }\n  \n      if (!handle || !handle.$$) {\n        throwBindingError(`Cannot pass \"${embindRepr(handle)}\" as a ${this.name}`);\n      }\n      if (!handle.$$.ptr) {\n        throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);\n      }\n      if (!this.isConst && handle.$$.ptrType.isConst) {\n        throwBindingError(`Cannot convert argument of type ${(handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name)} to parameter type ${this.name}`);\n      }\n      var handleClass = handle.$$.ptrType.registeredClass;\n      ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n  \n      if (this.isSmartPointer) {\n        // TODO: this is not strictly true\n        // We could support BY_EMVAL conversions from raw pointers to smart pointers\n        // because the smart pointer can hold a reference to the handle\n        if (undefined === handle.$$.smartPtr) {\n          throwBindingError('Passing raw pointer to smart pointer is illegal');\n        }\n  \n        switch (this.sharingPolicy) {\n          case 0: // NONE\n            // no upcasting\n            if (handle.$$.smartPtrType === this) {\n              ptr = handle.$$.smartPtr;\n            } else {\n              throwBindingError(`Cannot convert argument of type ${(handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name)} to parameter type ${this.name}`);\n            }\n            break;\n  \n          case 1: // INTRUSIVE\n            ptr = handle.$$.smartPtr;\n            break;\n  \n          case 2: // BY_EMVAL\n            if (handle.$$.smartPtrType === this) {\n              ptr = handle.$$.smartPtr;\n            } else {\n              var clonedHandle = handle['clone']();\n              ptr = this.rawShare(\n                ptr,\n                Emval.toHandle(() => clonedHandle['delete']())\n              );\n              if (destructors !== null) {\n                destructors.push(this.rawDestructor, ptr);\n              }\n            }\n            break;\n  \n          default:\n            throwBindingError('Unsupporting sharing policy');\n        }\n      }\n      return ptr;\n    }\n  \n  \n  \n  /** @suppress {globalThis} */\n  function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {\n      if (handle === null) {\n        if (this.isReference) {\n          throwBindingError(`null is not a valid ${this.name}`);\n        }\n        return 0;\n      }\n  \n      if (!handle.$$) {\n        throwBindingError(`Cannot pass \"${embindRepr(handle)}\" as a ${this.name}`);\n      }\n      if (!handle.$$.ptr) {\n        throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);\n      }\n      if (handle.$$.ptrType.isConst) {\n        throwBindingError(`Cannot convert argument of type ${handle.$$.ptrType.name} to parameter type ${this.name}`);\n      }\n      var handleClass = handle.$$.ptrType.registeredClass;\n      var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n      return ptr;\n    }\n  \n  \n  /** @suppress {globalThis} */\n  function readPointer(pointer) {\n      return this['fromWireType'](HEAPU32[((pointer)>>2)]);\n    }\n  \n  \n  var init_RegisteredPointer = () => {\n      Object.assign(RegisteredPointer.prototype, {\n        getPointee(ptr) {\n          if (this.rawGetPointee) {\n            ptr = this.rawGetPointee(ptr);\n          }\n          return ptr;\n        },\n        destructor(ptr) {\n          this.rawDestructor?.(ptr);\n        },\n        argPackAdvance: GenericWireTypeSize,\n        'readValueFromPointer': readPointer,\n        'fromWireType': RegisteredPointer_fromWireType,\n      });\n    };\n  /** @constructor\n      @param {*=} pointeeType,\n      @param {*=} sharingPolicy,\n      @param {*=} rawGetPointee,\n      @param {*=} rawConstructor,\n      @param {*=} rawShare,\n      @param {*=} rawDestructor,\n       */\n  function RegisteredPointer(\n      name,\n      registeredClass,\n      isReference,\n      isConst,\n  \n      // smart pointer properties\n      isSmartPointer,\n      pointeeType,\n      sharingPolicy,\n      rawGetPointee,\n      rawConstructor,\n      rawShare,\n      rawDestructor\n    ) {\n      this.name = name;\n      this.registeredClass = registeredClass;\n      this.isReference = isReference;\n      this.isConst = isConst;\n  \n      // smart pointer properties\n      this.isSmartPointer = isSmartPointer;\n      this.pointeeType = pointeeType;\n      this.sharingPolicy = sharingPolicy;\n      this.rawGetPointee = rawGetPointee;\n      this.rawConstructor = rawConstructor;\n      this.rawShare = rawShare;\n      this.rawDestructor = rawDestructor;\n  \n      if (!isSmartPointer && registeredClass.baseClass === undefined) {\n        if (isConst) {\n          this['toWireType'] = constNoSmartPtrRawPointerToWireType;\n          this.destructorFunction = null;\n        } else {\n          this['toWireType'] = nonConstNoSmartPtrRawPointerToWireType;\n          this.destructorFunction = null;\n        }\n      } else {\n        this['toWireType'] = genericPointerToWireType;\n        // Here we must leave this.destructorFunction undefined, since whether genericPointerToWireType returns\n        // a pointer that needs to be freed up is runtime-dependent, and cannot be evaluated at registration time.\n        // TODO: Create an alternative mechanism that allows removing the use of var destructors = []; array in\n        //       craftInvokerFunction altogether.\n      }\n    }\n  \n  /** @param {number=} numArguments */\n  var replacePublicSymbol = (name, value, numArguments) => {\n      if (!Module.hasOwnProperty(name)) {\n        throwInternalError('Replacing nonexistent public symbol');\n      }\n      // If there's an overload table for this symbol, replace the symbol in the overload table instead.\n      if (undefined !== Module[name].overloadTable && undefined !== numArguments) {\n        Module[name].overloadTable[numArguments] = value;\n      } else {\n        Module[name] = value;\n        Module[name].argCount = numArguments;\n      }\n    };\n  \n  \n  \n  var wasmTableMirror = [];\n  \n  /** @type {WebAssembly.Table} */\n  var wasmTable;\n  var getWasmTableEntry = (funcPtr) => {\n      var func = wasmTableMirror[funcPtr];\n      if (!func) {\n        /** @suppress {checkTypes} */\n        wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);\n      }\n      /** @suppress {checkTypes} */\n      assert(wasmTable.get(funcPtr) == func, 'JavaScript-side Wasm function table mirror is out of date!');\n      return func;\n    };\n  var embind__requireFunction = (signature, rawFunction, isAsync = false) => {\n      assert(!isAsync, 'Async bindings are only supported with JSPI.');\n  \n      signature = AsciiToString(signature);\n  \n      function makeDynCaller() {\n        var rtn = getWasmTableEntry(rawFunction);\n        return rtn;\n      }\n  \n      var fp = makeDynCaller();\n      if (typeof fp != 'function') {\n          throwBindingError(`unknown function pointer with signature ${signature}: ${rawFunction}`);\n      }\n      return fp;\n    };\n  \n  \n  \n  class UnboundTypeError extends Error {}\n  \n  \n  \n  var getTypeName = (type) => {\n      var ptr = ___getTypeName(type);\n      var rv = AsciiToString(ptr);\n      _free(ptr);\n      return rv;\n    };\n  var throwUnboundTypeError = (message, types) => {\n      var unboundTypes = [];\n      var seen = {};\n      function visit(type) {\n        if (seen[type]) {\n          return;\n        }\n        if (registeredTypes[type]) {\n          return;\n        }\n        if (typeDependencies[type]) {\n          typeDependencies[type].forEach(visit);\n          return;\n        }\n        unboundTypes.push(type);\n        seen[type] = true;\n      }\n      types.forEach(visit);\n  \n      throw new UnboundTypeError(`${message}: ` + unboundTypes.map(getTypeName).join([', ']));\n    };\n  \n  \n  \n  \n  var whenDependentTypesAreResolved = (myTypes, dependentTypes, getTypeConverters) => {\n      myTypes.forEach((type) => typeDependencies[type] = dependentTypes);\n  \n      function onComplete(typeConverters) {\n        var myTypeConverters = getTypeConverters(typeConverters);\n        if (myTypeConverters.length !== myTypes.length) {\n          throwInternalError('Mismatched type converter count');\n        }\n        for (var i = 0; i < myTypes.length; ++i) {\n          registerType(myTypes[i], myTypeConverters[i]);\n        }\n      }\n  \n      var typeConverters = new Array(dependentTypes.length);\n      var unregisteredTypes = [];\n      var registered = 0;\n      dependentTypes.forEach((dt, i) => {\n        if (registeredTypes.hasOwnProperty(dt)) {\n          typeConverters[i] = registeredTypes[dt];\n        } else {\n          unregisteredTypes.push(dt);\n          if (!awaitingDependencies.hasOwnProperty(dt)) {\n            awaitingDependencies[dt] = [];\n          }\n          awaitingDependencies[dt].push(() => {\n            typeConverters[i] = registeredTypes[dt];\n            ++registered;\n            if (registered === unregisteredTypes.length) {\n              onComplete(typeConverters);\n            }\n          });\n        }\n      });\n      if (0 === unregisteredTypes.length) {\n        onComplete(typeConverters);\n      }\n    };\n  var __embind_register_class = (rawType,\n                             rawPointerType,\n                             rawConstPointerType,\n                             baseClassRawType,\n                             getActualTypeSignature,\n                             getActualType,\n                             upcastSignature,\n                             upcast,\n                             downcastSignature,\n                             downcast,\n                             name,\n                             destructorSignature,\n                             rawDestructor) => {\n      name = AsciiToString(name);\n      getActualType = embind__requireFunction(getActualTypeSignature, getActualType);\n      upcast &&= embind__requireFunction(upcastSignature, upcast);\n      downcast &&= embind__requireFunction(downcastSignature, downcast);\n      rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);\n      var legalFunctionName = makeLegalFunctionName(name);\n  \n      exposePublicSymbol(legalFunctionName, function() {\n        // this code cannot run if baseClassRawType is zero\n        throwUnboundTypeError(`Cannot construct ${name} due to unbound types`, [baseClassRawType]);\n      });\n  \n      whenDependentTypesAreResolved(\n        [rawType, rawPointerType, rawConstPointerType],\n        baseClassRawType ? [baseClassRawType] : [],\n        (base) => {\n          base = base[0];\n  \n          var baseClass;\n          var basePrototype;\n          if (baseClassRawType) {\n            baseClass = base.registeredClass;\n            basePrototype = baseClass.instancePrototype;\n          } else {\n            basePrototype = ClassHandle.prototype;\n          }\n  \n          var constructor = createNamedFunction(name, function(...args) {\n            if (Object.getPrototypeOf(this) !== instancePrototype) {\n              throw new BindingError(`Use 'new' to construct ${name}`);\n            }\n            if (undefined === registeredClass.constructor_body) {\n              throw new BindingError(`${name} has no accessible constructor`);\n            }\n            var body = registeredClass.constructor_body[args.length];\n            if (undefined === body) {\n              throw new BindingError(`Tried to invoke ctor of ${name} with invalid number of parameters (${args.length}) - expected (${Object.keys(registeredClass.constructor_body).toString()}) parameters instead!`);\n            }\n            return body.apply(this, args);\n          });\n  \n          var instancePrototype = Object.create(basePrototype, {\n            constructor: { value: constructor },\n          });\n  \n          constructor.prototype = instancePrototype;\n  \n          var registeredClass = new RegisteredClass(name,\n                                                    constructor,\n                                                    instancePrototype,\n                                                    rawDestructor,\n                                                    baseClass,\n                                                    getActualType,\n                                                    upcast,\n                                                    downcast);\n  \n          if (registeredClass.baseClass) {\n            // Keep track of class hierarchy. Used to allow sub-classes to inherit class functions.\n            registeredClass.baseClass.__derivedClasses ??= [];\n  \n            registeredClass.baseClass.__derivedClasses.push(registeredClass);\n          }\n  \n          var referenceConverter = new RegisteredPointer(name,\n                                                         registeredClass,\n                                                         true,\n                                                         false,\n                                                         false);\n  \n          var pointerConverter = new RegisteredPointer(name + '*',\n                                                       registeredClass,\n                                                       false,\n                                                       false,\n                                                       false);\n  \n          var constPointerConverter = new RegisteredPointer(name + ' const*',\n                                                            registeredClass,\n                                                            false,\n                                                            true,\n                                                            false);\n  \n          registeredPointers[rawType] = {\n            pointerType: pointerConverter,\n            constPointerType: constPointerConverter\n          };\n  \n          replacePublicSymbol(legalFunctionName, constructor);\n  \n          return [referenceConverter, pointerConverter, constPointerConverter];\n        }\n      );\n    };\n\n  var heap32VectorToArray = (count, firstElement) => {\n      var array = [];\n      for (var i = 0; i < count; i++) {\n        // TODO(https://github.com/emscripten-core/emscripten/issues/17310):\n        // Find a way to hoist the `>> 2` or `>> 3` out of this loop.\n        array.push(HEAPU32[(((firstElement)+(i * 4))>>2)]);\n      }\n      return array;\n    };\n  \n  \n  \n  \n  var runDestructors = (destructors) => {\n      while (destructors.length) {\n        var ptr = destructors.pop();\n        var del = destructors.pop();\n        del(ptr);\n      }\n    };\n  \n  \n  function usesDestructorStack(argTypes) {\n      // Skip return value at index 0 - it's not deleted here.\n      for (var i = 1; i < argTypes.length; ++i) {\n        // The type does not define a destructor function - must use dynamic stack\n        if (argTypes[i] !== null && argTypes[i].destructorFunction === undefined) {\n          return true;\n        }\n      }\n      return false;\n    }\n  \n  \n  function checkArgCount(numArgs, minArgs, maxArgs, humanName, throwBindingError) {\n      if (numArgs < minArgs || numArgs > maxArgs) {\n        var argCountMessage = minArgs == maxArgs ? minArgs : `${minArgs} to ${maxArgs}`;\n        throwBindingError(`function ${humanName} called with ${numArgs} arguments, expected ${argCountMessage}`);\n      }\n    }\n  function createJsInvoker(argTypes, isClassMethodFunc, returns, isAsync) {\n      var needsDestructorStack = usesDestructorStack(argTypes);\n      var argCount = argTypes.length - 2;\n      var argsList = [];\n      var argsListWired = ['fn'];\n      if (isClassMethodFunc) {\n        argsListWired.push('thisWired');\n      }\n      for (var i = 0; i < argCount; ++i) {\n        argsList.push(`arg${i}`)\n        argsListWired.push(`arg${i}Wired`)\n      }\n      argsList = argsList.join(',')\n      argsListWired = argsListWired.join(',')\n  \n      var invokerFnBody = `return function (${argsList}) {\\n`;\n  \n      invokerFnBody += \"checkArgCount(arguments.length, minArgs, maxArgs, humanName, throwBindingError);\\n\";\n  \n      if (needsDestructorStack) {\n        invokerFnBody += \"var destructors = [];\\n\";\n      }\n  \n      var dtorStack = needsDestructorStack ? \"destructors\" : \"null\";\n      var args1 = [\"humanName\", \"throwBindingError\", \"invoker\", \"fn\", \"runDestructors\", \"retType\", \"classParam\"];\n  \n      if (isClassMethodFunc) {\n        invokerFnBody += `var thisWired = classParam['toWireType'](${dtorStack}, this);\\n`;\n      }\n  \n      for (var i = 0; i < argCount; ++i) {\n        invokerFnBody += `var arg${i}Wired = argType${i}['toWireType'](${dtorStack}, arg${i});\\n`;\n        args1.push(`argType${i}`);\n      }\n  \n      invokerFnBody += (returns || isAsync ? \"var rv = \":\"\") + `invoker(${argsListWired});\\n`;\n  \n      var returnVal = returns ? \"rv\" : \"\";\n  \n      if (needsDestructorStack) {\n        invokerFnBody += \"runDestructors(destructors);\\n\";\n      } else {\n        for (var i = isClassMethodFunc?1:2; i < argTypes.length; ++i) { // Skip return value at index 0 - it's not deleted here. Also skip class type if not a method.\n          var paramName = (i === 1 ? \"thisWired\" : (\"arg\"+(i - 2)+\"Wired\"));\n          if (argTypes[i].destructorFunction !== null) {\n            invokerFnBody += `${paramName}_dtor(${paramName});\\n`;\n            args1.push(`${paramName}_dtor`);\n          }\n        }\n      }\n  \n      if (returns) {\n        invokerFnBody += \"var ret = retType['fromWireType'](rv);\\n\" +\n                         \"return ret;\\n\";\n      } else {\n      }\n  \n      invokerFnBody += \"}\\n\";\n  \n      args1.push('checkArgCount', 'minArgs', 'maxArgs');\n      invokerFnBody = `if (arguments.length !== ${args1.length}){ throw new Error(humanName + \"Expected ${args1.length} closure arguments \" + arguments.length + \" given.\"); }\\n${invokerFnBody}`;\n      return [args1, invokerFnBody];\n    }\n  \n  function getRequiredArgCount(argTypes) {\n      var requiredArgCount = argTypes.length - 2;\n      for (var i = argTypes.length - 1; i >= 2; --i) {\n        if (!argTypes[i].optional) {\n          break;\n        }\n        requiredArgCount--;\n      }\n      return requiredArgCount;\n    }\n  \n  function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc, /** boolean= */ isAsync) {\n      // humanName: a human-readable string name for the function to be generated.\n      // argTypes: An array that contains the embind type objects for all types in the function signature.\n      //    argTypes[0] is the type object for the function return value.\n      //    argTypes[1] is the type object for function this object/class type, or null if not crafting an invoker for a class method.\n      //    argTypes[2...] are the actual function parameters.\n      // classType: The embind type object for the class to be bound, or null if this is not a method of a class.\n      // cppInvokerFunc: JS Function object to the C++-side function that interops into C++ code.\n      // cppTargetFunc: Function pointer (an integer to FUNCTION_TABLE) to the target C++ function the cppInvokerFunc will end up calling.\n      // isAsync: Optional. If true, returns an async function. Async bindings are only supported with JSPI.\n      var argCount = argTypes.length;\n  \n      if (argCount < 2) {\n        throwBindingError(\"argTypes array size mismatch! Must at least get return value and 'this' types!\");\n      }\n  \n      assert(!isAsync, 'Async bindings are only supported with JSPI.');\n      var isClassMethodFunc = (argTypes[1] !== null && classType !== null);\n  \n      // Free functions with signature \"void function()\" do not need an invoker that marshalls between wire types.\n      // TODO: This omits argument count check - enable only at -O3 or similar.\n      //    if (ENABLE_UNSAFE_OPTS && argCount == 2 && argTypes[0].name == \"void\" && !isClassMethodFunc) {\n      //       return FUNCTION_TABLE[fn];\n      //    }\n  \n      // Determine if we need to use a dynamic stack to store the destructors for the function parameters.\n      // TODO: Remove this completely once all function invokers are being dynamically generated.\n      var needsDestructorStack = usesDestructorStack(argTypes);\n  \n      var returns = (argTypes[0].name !== 'void');\n  \n      var expectedArgCount = argCount - 2;\n      var minArgs = getRequiredArgCount(argTypes);\n      // Builld the arguments that will be passed into the closure around the invoker\n      // function.\n      var closureArgs = [humanName, throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, argTypes[0], argTypes[1]];\n      for (var i = 0; i < argCount - 2; ++i) {\n        closureArgs.push(argTypes[i+2]);\n      }\n      if (!needsDestructorStack) {\n        // Skip return value at index 0 - it's not deleted here. Also skip class type if not a method.\n        for (var i = isClassMethodFunc?1:2; i < argTypes.length; ++i) {\n          if (argTypes[i].destructorFunction !== null) {\n            closureArgs.push(argTypes[i].destructorFunction);\n          }\n        }\n      }\n      closureArgs.push(checkArgCount, minArgs, expectedArgCount);\n  \n      let [args, invokerFnBody] = createJsInvoker(argTypes, isClassMethodFunc, returns, isAsync);\n      var invokerFn = new Function(...args, invokerFnBody)(...closureArgs);\n      return createNamedFunction(humanName, invokerFn);\n    }\n  var __embind_register_class_constructor = (\n      rawClassType,\n      argCount,\n      rawArgTypesAddr,\n      invokerSignature,\n      invoker,\n      rawConstructor\n    ) => {\n      assert(argCount > 0);\n      var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n      invoker = embind__requireFunction(invokerSignature, invoker);\n      var args = [rawConstructor];\n      var destructors = [];\n  \n      whenDependentTypesAreResolved([], [rawClassType], (classType) => {\n        classType = classType[0];\n        var humanName = `constructor ${classType.name}`;\n  \n        if (undefined === classType.registeredClass.constructor_body) {\n          classType.registeredClass.constructor_body = [];\n        }\n        if (undefined !== classType.registeredClass.constructor_body[argCount - 1]) {\n          throw new BindingError(`Cannot register multiple constructors with identical number of parameters (${argCount-1}) for class '${classType.name}'! Overload resolution is currently only performed using the parameter count, not actual type info!`);\n        }\n        classType.registeredClass.constructor_body[argCount - 1] = () => {\n          throwUnboundTypeError(`Cannot construct ${classType.name} due to unbound types`, rawArgTypes);\n        };\n  \n        whenDependentTypesAreResolved([], rawArgTypes, (argTypes) => {\n          // Insert empty slot for context type (argTypes[1]).\n          argTypes.splice(1, 0, null);\n          classType.registeredClass.constructor_body[argCount - 1] = craftInvokerFunction(humanName, argTypes, null, invoker, rawConstructor);\n          return [];\n        });\n        return [];\n      });\n    };\n\n  \n  \n  \n  \n  \n  \n  var getFunctionName = (signature) => {\n      signature = signature.trim();\n      const argsIndex = signature.indexOf(\"(\");\n      if (argsIndex === -1) return signature;\n      assert(signature.endsWith(\")\"), \"Parentheses for argument names should match.\");\n      return signature.slice(0, argsIndex);\n    };\n  var __embind_register_class_function = (rawClassType,\n                                      methodName,\n                                      argCount,\n                                      rawArgTypesAddr, // [ReturnType, ThisType, Args...]\n                                      invokerSignature,\n                                      rawInvoker,\n                                      context,\n                                      isPureVirtual,\n                                      isAsync,\n                                      isNonnullReturn) => {\n      var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n      methodName = AsciiToString(methodName);\n      methodName = getFunctionName(methodName);\n      rawInvoker = embind__requireFunction(invokerSignature, rawInvoker, isAsync);\n  \n      whenDependentTypesAreResolved([], [rawClassType], (classType) => {\n        classType = classType[0];\n        var humanName = `${classType.name}.${methodName}`;\n  \n        if (methodName.startsWith(\"@@\")) {\n          methodName = Symbol[methodName.substring(2)];\n        }\n  \n        if (isPureVirtual) {\n          classType.registeredClass.pureVirtualFunctions.push(methodName);\n        }\n  \n        function unboundTypesHandler() {\n          throwUnboundTypeError(`Cannot call ${humanName} due to unbound types`, rawArgTypes);\n        }\n  \n        var proto = classType.registeredClass.instancePrototype;\n        var method = proto[methodName];\n        if (undefined === method || (undefined === method.overloadTable && method.className !== classType.name && method.argCount === argCount - 2)) {\n          // This is the first overload to be registered, OR we are replacing a\n          // function in the base class with a function in the derived class.\n          unboundTypesHandler.argCount = argCount - 2;\n          unboundTypesHandler.className = classType.name;\n          proto[methodName] = unboundTypesHandler;\n        } else {\n          // There was an existing function with the same name registered. Set up\n          // a function overload routing table.\n          ensureOverloadTable(proto, methodName, humanName);\n          proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;\n        }\n  \n        whenDependentTypesAreResolved([], rawArgTypes, (argTypes) => {\n          var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context, isAsync);\n  \n          // Replace the initial unbound-handler-stub function with the\n          // appropriate member function, now that all types are resolved. If\n          // multiple overloads are registered for this function, the function\n          // goes into an overload table.\n          if (undefined === proto[methodName].overloadTable) {\n            // Set argCount in case an overload is registered later\n            memberFunction.argCount = argCount - 2;\n            proto[methodName] = memberFunction;\n          } else {\n            proto[methodName].overloadTable[argCount - 2] = memberFunction;\n          }\n  \n          return [];\n        });\n        return [];\n      });\n    };\n\n  \n  var emval_freelist = [];\n  \n  var emval_handles = [0,1,,1,null,1,true,1,false,1];\n  var __emval_decref = (handle) => {\n      if (handle > 9 && 0 === --emval_handles[handle + 1]) {\n        assert(emval_handles[handle] !== undefined, `Decref for unallocated handle.`);\n        emval_handles[handle] = undefined;\n        emval_freelist.push(handle);\n      }\n    };\n  \n  \n  \n  var Emval = {\n  toValue:(handle) => {\n        if (!handle) {\n            throwBindingError(`Cannot use deleted val. handle = ${handle}`);\n        }\n        // handle 2 is supposed to be `undefined`.\n        assert(handle === 2 || emval_handles[handle] !== undefined && handle % 2 === 0, `invalid handle: ${handle}`);\n        return emval_handles[handle];\n      },\n  toHandle:(value) => {\n        switch (value) {\n          case undefined: return 2;\n          case null: return 4;\n          case true: return 6;\n          case false: return 8;\n          default:{\n            const handle = emval_freelist.pop() || emval_handles.length;\n            emval_handles[handle] = value;\n            emval_handles[handle + 1] = 1;\n            return handle;\n          }\n        }\n      },\n  };\n  \n  \n  var EmValType = {\n      name: 'emscripten::val',\n      'fromWireType': (handle) => {\n        var rv = Emval.toValue(handle);\n        __emval_decref(handle);\n        return rv;\n      },\n      'toWireType': (destructors, value) => Emval.toHandle(value),\n      argPackAdvance: GenericWireTypeSize,\n      'readValueFromPointer': readPointer,\n      destructorFunction: null, // This type does not need a destructor\n  \n      // TODO: do we need a deleteObject here?  write a test where\n      // emval is passed into JS via an interface\n    };\n  var __embind_register_emval = (rawType) => registerType(rawType, EmValType);\n\n  var floatReadValueFromPointer = (name, width) => {\n      switch (width) {\n        case 4: return function(pointer) {\n          return this['fromWireType'](HEAPF32[((pointer)>>2)]);\n        };\n        case 8: return function(pointer) {\n          return this['fromWireType'](HEAPF64[((pointer)>>3)]);\n        };\n        default:\n          throw new TypeError(`invalid float width (${width}): ${name}`);\n      }\n    };\n  \n  \n  \n  var __embind_register_float = (rawType, name, size) => {\n      name = AsciiToString(name);\n      registerType(rawType, {\n        name,\n        'fromWireType': (value) => value,\n        'toWireType': (destructors, value) => {\n          if (typeof value != \"number\" && typeof value != \"boolean\") {\n            throw new TypeError(`Cannot convert ${embindRepr(value)} to ${this.name}`);\n          }\n          // The VM will perform JS to Wasm value conversion, according to the spec:\n          // https://www.w3.org/TR/wasm-js-api-1/#towebassemblyvalue\n          return value;\n        },\n        argPackAdvance: GenericWireTypeSize,\n        'readValueFromPointer': floatReadValueFromPointer(name, size),\n        destructorFunction: null, // This type does not need a destructor\n      });\n    };\n\n  \n  \n  \n  \n  \n  \n  \n  \n  var __embind_register_function = (name, argCount, rawArgTypesAddr, signature, rawInvoker, fn, isAsync, isNonnullReturn) => {\n      var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n      name = AsciiToString(name);\n      name = getFunctionName(name);\n  \n      rawInvoker = embind__requireFunction(signature, rawInvoker, isAsync);\n  \n      exposePublicSymbol(name, function() {\n        throwUnboundTypeError(`Cannot call ${name} due to unbound types`, argTypes);\n      }, argCount - 1);\n  \n      whenDependentTypesAreResolved([], argTypes, (argTypes) => {\n        var invokerArgsArray = [argTypes[0] /* return value */, null /* no class 'this'*/].concat(argTypes.slice(1) /* actual params */);\n        replacePublicSymbol(name, craftInvokerFunction(name, invokerArgsArray, null /* no class 'this'*/, rawInvoker, fn, isAsync), argCount - 1);\n        return [];\n      });\n    };\n\n  \n  \n  \n  \n  /** @suppress {globalThis} */\n  var __embind_register_integer = (primitiveType, name, size, minRange, maxRange) => {\n      name = AsciiToString(name);\n  \n      const isUnsignedType = minRange === 0;\n  \n      let fromWireType = (value) => value;\n      if (isUnsignedType) {\n        var bitshift = 32 - 8*size;\n        fromWireType = (value) => (value << bitshift) >>> bitshift;\n        maxRange = fromWireType(maxRange);\n      }\n  \n      registerType(primitiveType, {\n        name,\n        'fromWireType': fromWireType,\n        'toWireType': (destructors, value) => {\n          if (typeof value != \"number\" && typeof value != \"boolean\") {\n            throw new TypeError(`Cannot convert \"${embindRepr(value)}\" to ${name}`);\n          }\n          assertIntegerRange(name, value, minRange, maxRange);\n          // The VM will perform JS to Wasm value conversion, according to the spec:\n          // https://www.w3.org/TR/wasm-js-api-1/#towebassemblyvalue\n          return value;\n        },\n        argPackAdvance: GenericWireTypeSize,\n        'readValueFromPointer': integerReadValueFromPointer(name, size, minRange !== 0),\n        destructorFunction: null, // This type does not need a destructor\n      });\n    };\n\n  \n  var __embind_register_memory_view = (rawType, dataTypeIndex, name) => {\n      var typeMapping = [\n        Int8Array,\n        Uint8Array,\n        Int16Array,\n        Uint16Array,\n        Int32Array,\n        Uint32Array,\n        Float32Array,\n        Float64Array,\n        BigInt64Array,\n        BigUint64Array,\n      ];\n  \n      var TA = typeMapping[dataTypeIndex];\n  \n      function decodeMemoryView(handle) {\n        var size = HEAPU32[((handle)>>2)];\n        var data = HEAPU32[(((handle)+(4))>>2)];\n        return new TA(HEAP8.buffer, data, size);\n      }\n  \n      name = AsciiToString(name);\n      registerType(rawType, {\n        name,\n        'fromWireType': decodeMemoryView,\n        argPackAdvance: GenericWireTypeSize,\n        'readValueFromPointer': decodeMemoryView,\n      }, {\n        ignoreDuplicateRegistrations: true,\n      });\n    };\n\n  \n  var EmValOptionalType = Object.assign({optional: true}, EmValType);;\n  var __embind_register_optional = (rawOptionalType, rawType) => {\n      registerType(rawOptionalType, EmValOptionalType);\n    };\n\n  \n  \n  \n  \n  var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {\n      assert(typeof str === 'string', `stringToUTF8Array expects a string (got ${typeof str})`);\n      // Parameter maxBytesToWrite is not optional. Negative values, 0, null,\n      // undefined and false each don't write out any bytes.\n      if (!(maxBytesToWrite > 0))\n        return 0;\n  \n      var startIdx = outIdx;\n      var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.\n      for (var i = 0; i < str.length; ++i) {\n        // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description\n        // and https://www.ietf.org/rfc/rfc2279.txt\n        // and https://tools.ietf.org/html/rfc3629\n        var u = str.codePointAt(i);\n        if (u <= 0x7F) {\n          if (outIdx >= endIdx) break;\n          heap[outIdx++] = u;\n        } else if (u <= 0x7FF) {\n          if (outIdx + 1 >= endIdx) break;\n          heap[outIdx++] = 0xC0 | (u >> 6);\n          heap[outIdx++] = 0x80 | (u & 63);\n        } else if (u <= 0xFFFF) {\n          if (outIdx + 2 >= endIdx) break;\n          heap[outIdx++] = 0xE0 | (u >> 12);\n          heap[outIdx++] = 0x80 | ((u >> 6) & 63);\n          heap[outIdx++] = 0x80 | (u & 63);\n        } else {\n          if (outIdx + 3 >= endIdx) break;\n          if (u > 0x10FFFF) warnOnce('Invalid Unicode code point ' + ptrToString(u) + ' encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF).');\n          heap[outIdx++] = 0xF0 | (u >> 18);\n          heap[outIdx++] = 0x80 | ((u >> 12) & 63);\n          heap[outIdx++] = 0x80 | ((u >> 6) & 63);\n          heap[outIdx++] = 0x80 | (u & 63);\n          // Gotcha: if codePoint is over 0xFFFF, it is represented as a surrogate pair in UTF-16.\n          // We need to manually skip over the second code unit for correct iteration.\n          i++;\n        }\n      }\n      // Null-terminate the pointer to the buffer.\n      heap[outIdx] = 0;\n      return outIdx - startIdx;\n    };\n  var stringToUTF8 = (str, outPtr, maxBytesToWrite) => {\n      assert(typeof maxBytesToWrite == 'number', 'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');\n      return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\n    };\n  \n  var lengthBytesUTF8 = (str) => {\n      var len = 0;\n      for (var i = 0; i < str.length; ++i) {\n        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code\n        // unit, not a Unicode code point of the character! So decode\n        // UTF16->UTF32->UTF8.\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\n        var c = str.charCodeAt(i); // possibly a lead surrogate\n        if (c <= 0x7F) {\n          len++;\n        } else if (c <= 0x7FF) {\n          len += 2;\n        } else if (c >= 0xD800 && c <= 0xDFFF) {\n          len += 4; ++i;\n        } else {\n          len += 3;\n        }\n      }\n      return len;\n    };\n  \n  \n  \n  var UTF8Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder() : undefined;\n  \n    /**\n     * Given a pointer 'idx' to a null-terminated UTF8-encoded string in the given\n     * array that contains uint8 values, returns a copy of that string as a\n     * Javascript String object.\n     * heapOrArray is either a regular array, or a JavaScript typed array view.\n     * @param {number=} idx\n     * @param {number=} maxBytesToRead\n     * @return {string}\n     */\n  var UTF8ArrayToString = (heapOrArray, idx = 0, maxBytesToRead = NaN) => {\n      var endIdx = idx + maxBytesToRead;\n      var endPtr = idx;\n      // TextDecoder needs to know the byte length in advance, it doesn't stop on\n      // null terminator by itself.  Also, use the length info to avoid running tiny\n      // strings through TextDecoder, since .subarray() allocates garbage.\n      // (As a tiny code save trick, compare endPtr against endIdx using a negation,\n      // so that undefined/NaN means Infinity)\n      while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;\n  \n      // When using conditional TextDecoder, skip it for short strings as the overhead of the native call is not worth it.\n      if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {\n        return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));\n      }\n      var str = '';\n      // If building with TextDecoder, we have already computed the string length\n      // above, so test loop end condition against that\n      while (idx < endPtr) {\n        // For UTF8 byte structure, see:\n        // http://en.wikipedia.org/wiki/UTF-8#Description\n        // https://www.ietf.org/rfc/rfc2279.txt\n        // https://tools.ietf.org/html/rfc3629\n        var u0 = heapOrArray[idx++];\n        if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }\n        var u1 = heapOrArray[idx++] & 63;\n        if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }\n        var u2 = heapOrArray[idx++] & 63;\n        if ((u0 & 0xF0) == 0xE0) {\n          u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;\n        } else {\n          if ((u0 & 0xF8) != 0xF0) warnOnce('Invalid UTF-8 leading byte ' + ptrToString(u0) + ' encountered when deserializing a UTF-8 string in wasm memory to a JS string!');\n          u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heapOrArray[idx++] & 63);\n        }\n  \n        if (u0 < 0x10000) {\n          str += String.fromCharCode(u0);\n        } else {\n          var ch = u0 - 0x10000;\n          str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));\n        }\n      }\n      return str;\n    };\n  \n    /**\n     * Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the\n     * emscripten HEAP, returns a copy of that string as a Javascript String object.\n     *\n     * @param {number} ptr\n     * @param {number=} maxBytesToRead - An optional length that specifies the\n     *   maximum number of bytes to read. You can omit this parameter to scan the\n     *   string until the first 0 byte. If maxBytesToRead is passed, and the string\n     *   at [ptr, ptr+maxBytesToReadr[ contains a null byte in the middle, then the\n     *   string will cut short at that byte index (i.e. maxBytesToRead will not\n     *   produce a string of exact length [ptr, ptr+maxBytesToRead[) N.B. mixing\n     *   frequent uses of UTF8ToString() with and without maxBytesToRead may throw\n     *   JS JIT optimizations off, so it is worth to consider consistently using one\n     * @return {string}\n     */\n  var UTF8ToString = (ptr, maxBytesToRead) => {\n      assert(typeof ptr == 'number', `UTF8ToString expects a number (got ${typeof ptr})`);\n      return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';\n    };\n  var __embind_register_std_string = (rawType, name) => {\n      name = AsciiToString(name);\n      var stdStringIsUTF8\n      = true;\n  \n      registerType(rawType, {\n        name,\n        // For some method names we use string keys here since they are part of\n        // the public/external API and/or used by the runtime-generated code.\n        'fromWireType'(value) {\n          var length = HEAPU32[((value)>>2)];\n          var payload = value + 4;\n  \n          var str;\n          if (stdStringIsUTF8) {\n            var decodeStartPtr = payload;\n            // Looping here to support possible embedded '0' bytes\n            for (var i = 0; i <= length; ++i) {\n              var currentBytePtr = payload + i;\n              if (i == length || HEAPU8[currentBytePtr] == 0) {\n                var maxRead = currentBytePtr - decodeStartPtr;\n                var stringSegment = UTF8ToString(decodeStartPtr, maxRead);\n                if (str === undefined) {\n                  str = stringSegment;\n                } else {\n                  str += String.fromCharCode(0);\n                  str += stringSegment;\n                }\n                decodeStartPtr = currentBytePtr + 1;\n              }\n            }\n          } else {\n            var a = new Array(length);\n            for (var i = 0; i < length; ++i) {\n              a[i] = String.fromCharCode(HEAPU8[payload + i]);\n            }\n            str = a.join('');\n          }\n  \n          _free(value);\n  \n          return str;\n        },\n        'toWireType'(destructors, value) {\n          if (value instanceof ArrayBuffer) {\n            value = new Uint8Array(value);\n          }\n  \n          var length;\n          var valueIsOfTypeString = (typeof value == 'string');\n  \n          // We accept `string` or array views with single byte elements\n          if (!(valueIsOfTypeString || (ArrayBuffer.isView(value) && value.BYTES_PER_ELEMENT == 1))) {\n            throwBindingError('Cannot pass non-string to std::string');\n          }\n          if (stdStringIsUTF8 && valueIsOfTypeString) {\n            length = lengthBytesUTF8(value);\n          } else {\n            length = value.length;\n          }\n  \n          // assumes POINTER_SIZE alignment\n          var base = _malloc(4 + length + 1);\n          var ptr = base + 4;\n          HEAPU32[((base)>>2)] = length;\n          if (valueIsOfTypeString) {\n            if (stdStringIsUTF8) {\n              stringToUTF8(value, ptr, length + 1);\n            } else {\n              for (var i = 0; i < length; ++i) {\n                var charCode = value.charCodeAt(i);\n                if (charCode > 255) {\n                  _free(base);\n                  throwBindingError('String has UTF-16 code units that do not fit in 8 bits');\n                }\n                HEAPU8[ptr + i] = charCode;\n              }\n            }\n          } else {\n            HEAPU8.set(value, ptr);\n          }\n  \n          if (destructors !== null) {\n            destructors.push(_free, base);\n          }\n          return base;\n        },\n        argPackAdvance: GenericWireTypeSize,\n        'readValueFromPointer': readPointer,\n        destructorFunction(ptr) {\n          _free(ptr);\n        },\n      });\n    };\n\n  \n  \n  \n  var UTF16Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder('utf-16le') : undefined;;\n  var UTF16ToString = (ptr, maxBytesToRead) => {\n      assert(ptr % 2 == 0, 'Pointer passed to UTF16ToString must be aligned to two bytes!');\n      var idx = ((ptr)>>1);\n      var maxIdx = idx + maxBytesToRead / 2;\n      // TextDecoder needs to know the byte length in advance, it doesn't stop on\n      // null terminator by itself.\n      // Also, use the length info to avoid running tiny strings through\n      // TextDecoder, since .subarray() allocates garbage.\n      var endIdx = idx;\n      // If maxBytesToRead is not passed explicitly, it will be undefined, and this\n      // will always evaluate to true. This saves on code size.\n      while (!(endIdx >= maxIdx) && HEAPU16[endIdx]) ++endIdx;\n  \n      if (endIdx - idx > 16 && UTF16Decoder)\n        return UTF16Decoder.decode(HEAPU16.subarray(idx, endIdx));\n  \n      // Fallback: decode without UTF16Decoder\n      var str = '';\n  \n      // If maxBytesToRead is not passed explicitly, it will be undefined, and the\n      // for-loop's condition will always evaluate to true. The loop is then\n      // terminated on the first null char.\n      for (var i = idx; !(i >= maxIdx); ++i) {\n        var codeUnit = HEAPU16[i];\n        if (codeUnit == 0) break;\n        // fromCharCode constructs a character from a UTF-16 code unit, so we can\n        // pass the UTF16 string right through.\n        str += String.fromCharCode(codeUnit);\n      }\n  \n      return str;\n    };\n  \n  var stringToUTF16 = (str, outPtr, maxBytesToWrite) => {\n      assert(outPtr % 2 == 0, 'Pointer passed to stringToUTF16 must be aligned to two bytes!');\n      assert(typeof maxBytesToWrite == 'number', 'stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');\n      // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\n      maxBytesToWrite ??= 0x7FFFFFFF;\n      if (maxBytesToWrite < 2) return 0;\n      maxBytesToWrite -= 2; // Null terminator.\n      var startPtr = outPtr;\n      var numCharsToWrite = (maxBytesToWrite < str.length*2) ? (maxBytesToWrite / 2) : str.length;\n      for (var i = 0; i < numCharsToWrite; ++i) {\n        // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.\n        var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\n        HEAP16[((outPtr)>>1)] = codeUnit;\n        outPtr += 2;\n      }\n      // Null-terminate the pointer to the HEAP.\n      HEAP16[((outPtr)>>1)] = 0;\n      return outPtr - startPtr;\n    };\n  \n  var lengthBytesUTF16 = (str) => str.length*2;\n  \n  var UTF32ToString = (ptr, maxBytesToRead) => {\n      assert(ptr % 4 == 0, 'Pointer passed to UTF32ToString must be aligned to four bytes!');\n      var str = '';\n      // If maxBytesToRead is not passed explicitly, it will be undefined, and this\n      // will always evaluate to true. This saves on code size.\n      for (var i = 0; !(i >= maxBytesToRead / 4); i++) {\n        var utf32 = HEAP32[(((ptr)+(i*4))>>2)];\n        if (!utf32) break;\n        str += String.fromCodePoint(utf32);\n      }\n      return str;\n    };\n  \n  var stringToUTF32 = (str, outPtr, maxBytesToWrite) => {\n      assert(outPtr % 4 == 0, 'Pointer passed to stringToUTF32 must be aligned to four bytes!');\n      assert(typeof maxBytesToWrite == 'number', 'stringToUTF32(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');\n      // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\n      maxBytesToWrite ??= 0x7FFFFFFF;\n      if (maxBytesToWrite < 4) return 0;\n      var startPtr = outPtr;\n      var endPtr = startPtr + maxBytesToWrite - 4;\n      for (var i = 0; i < str.length; ++i) {\n        var codePoint = str.codePointAt(i);\n        // Gotcha: if codePoint is over 0xFFFF, it is represented as a surrogate pair in UTF-16.\n        // We need to manually skip over the second code unit for correct iteration.\n        if (codePoint > 0xFFFF) {\n          i++;\n        }\n        HEAP32[((outPtr)>>2)] = codePoint;\n        outPtr += 4;\n        if (outPtr + 4 > endPtr) break;\n      }\n      // Null-terminate the pointer to the HEAP.\n      HEAP32[((outPtr)>>2)] = 0;\n      return outPtr - startPtr;\n    };\n  \n  var lengthBytesUTF32 = (str) => {\n      var len = 0;\n      for (var i = 0; i < str.length; ++i) {\n        var codePoint = str.codePointAt(i);\n        // Gotcha: if codePoint is over 0xFFFF, it is represented as a surrogate pair in UTF-16.\n        // We need to manually skip over the second code unit for correct iteration.\n        if (codePoint > 0xFFFF) {\n          i++;\n        }\n        len += 4;\n      }\n  \n      return len;\n    };\n  var __embind_register_std_wstring = (rawType, charSize, name) => {\n      name = AsciiToString(name);\n      var decodeString, encodeString, readCharAt, lengthBytesUTF;\n      if (charSize === 2) {\n        decodeString = UTF16ToString;\n        encodeString = stringToUTF16;\n        lengthBytesUTF = lengthBytesUTF16;\n        readCharAt = (pointer) => HEAPU16[((pointer)>>1)];\n      } else if (charSize === 4) {\n        decodeString = UTF32ToString;\n        encodeString = stringToUTF32;\n        lengthBytesUTF = lengthBytesUTF32;\n        readCharAt = (pointer) => HEAPU32[((pointer)>>2)];\n      }\n      registerType(rawType, {\n        name,\n        'fromWireType': (value) => {\n          // Code mostly taken from _embind_register_std_string fromWireType\n          var length = HEAPU32[((value)>>2)];\n          var str;\n  \n          var decodeStartPtr = value + 4;\n          // Looping here to support possible embedded '0' bytes\n          for (var i = 0; i <= length; ++i) {\n            var currentBytePtr = value + 4 + i * charSize;\n            if (i == length || readCharAt(currentBytePtr) == 0) {\n              var maxReadBytes = currentBytePtr - decodeStartPtr;\n              var stringSegment = decodeString(decodeStartPtr, maxReadBytes);\n              if (str === undefined) {\n                str = stringSegment;\n              } else {\n                str += String.fromCharCode(0);\n                str += stringSegment;\n              }\n              decodeStartPtr = currentBytePtr + charSize;\n            }\n          }\n  \n          _free(value);\n  \n          return str;\n        },\n        'toWireType': (destructors, value) => {\n          if (!(typeof value == 'string')) {\n            throwBindingError(`Cannot pass non-string to C++ string type ${name}`);\n          }\n  \n          // assumes POINTER_SIZE alignment\n          var length = lengthBytesUTF(value);\n          var ptr = _malloc(4 + length + charSize);\n          HEAPU32[((ptr)>>2)] = length / charSize;\n  \n          encodeString(value, ptr + 4, length + charSize);\n  \n          if (destructors !== null) {\n            destructors.push(_free, ptr);\n          }\n          return ptr;\n        },\n        argPackAdvance: GenericWireTypeSize,\n        'readValueFromPointer': readPointer,\n        destructorFunction(ptr) {\n          _free(ptr);\n        }\n      });\n    };\n\n  \n  var __embind_register_void = (rawType, name) => {\n      name = AsciiToString(name);\n      registerType(rawType, {\n        isVoid: true, // void return values can be optimized out sometimes\n        name,\n        argPackAdvance: 0,\n        'fromWireType': () => undefined,\n        // TODO: assert if anything else is given?\n        'toWireType': (destructors, o) => undefined,\n      });\n    };\n\n\n  \n  \n  \n  var requireRegisteredType = (rawType, humanName) => {\n      var impl = registeredTypes[rawType];\n      if (undefined === impl) {\n        throwBindingError(`${humanName} has unknown type ${getTypeName(rawType)}`);\n      }\n      return impl;\n    };\n  var __emval_take_value = (type, arg) => {\n      type = requireRegisteredType(type, '_emval_take_value');\n      var v = type['readValueFromPointer'](arg);\n      return Emval.toHandle(v);\n    };\n\n  var abortOnCannotGrowMemory = (requestedSize) => {\n      abort(`Cannot enlarge memory arrays to size ${requestedSize} bytes (OOM). Either (1) compile with -sINITIAL_MEMORY=X with X higher than the current value ${HEAP8.length}, (2) compile with -sALLOW_MEMORY_GROWTH which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with -sABORTING_MALLOC=0`);\n    };\n  var _emscripten_resize_heap = (requestedSize) => {\n      var oldSize = HEAPU8.length;\n      // With CAN_ADDRESS_2GB or MEMORY64, pointers are already unsigned.\n      requestedSize >>>= 0;\n      abortOnCannotGrowMemory(requestedSize);\n    };\n\n  var SYSCALLS = {\n  varargs:undefined,\n  getStr(ptr) {\n        var ret = UTF8ToString(ptr);\n        return ret;\n      },\n  };\n  var _fd_close = (fd) => {\n      abort('fd_close called without SYSCALLS_REQUIRE_FILESYSTEM');\n    };\n\n  var INT53_MAX = 9007199254740992;\n  \n  var INT53_MIN = -9007199254740992;\n  var bigintToI53Checked = (num) => (num < INT53_MIN || num > INT53_MAX) ? NaN : Number(num);\n  function _fd_seek(fd, offset, whence, newOffset) {\n    offset = bigintToI53Checked(offset);\n  \n  \n      return 70;\n    ;\n  }\n\n  var printCharBuffers = [null,[],[]];\n  \n  var printChar = (stream, curr) => {\n      var buffer = printCharBuffers[stream];\n      assert(buffer);\n      if (curr === 0 || curr === 10) {\n        (stream === 1 ? out : err)(UTF8ArrayToString(buffer));\n        buffer.length = 0;\n      } else {\n        buffer.push(curr);\n      }\n    };\n  \n  var flush_NO_FILESYSTEM = () => {\n      // flush anything remaining in the buffers during shutdown\n      _fflush(0);\n      if (printCharBuffers[1].length) printChar(1, 10);\n      if (printCharBuffers[2].length) printChar(2, 10);\n    };\n  \n  \n  var _fd_write = (fd, iov, iovcnt, pnum) => {\n      // hack to support printf in SYSCALLS_REQUIRE_FILESYSTEM=0\n      var num = 0;\n      for (var i = 0; i < iovcnt; i++) {\n        var ptr = HEAPU32[((iov)>>2)];\n        var len = HEAPU32[(((iov)+(4))>>2)];\n        iov += 8;\n        for (var j = 0; j < len; j++) {\n          printChar(fd, HEAPU8[ptr+j]);\n        }\n        num += len;\n      }\n      HEAPU32[((pnum)>>2)] = num;\n      return 0;\n    };\ninit_ClassHandle();\ninit_RegisteredPointer();\nassert(emval_handles.length === 5 * 2);\n// End JS library code\n\n// include: postlibrary.js\n// This file is included after the automatically-generated JS library code\n// but before the wasm module is created.\n\n{\n\n  // Begin ATMODULES hooks\n  if (Module['noExitRuntime']) noExitRuntime = Module['noExitRuntime'];\nif (Module['print']) out = Module['print'];\nif (Module['printErr']) err = Module['printErr'];\nif (Module['wasmBinary']) wasmBinary = Module['wasmBinary'];\n\nModule['FS_createDataFile'] = FS.createDataFile;\nModule['FS_createPreloadedFile'] = FS.createPreloadedFile;\n\n  // End ATMODULES hooks\n\n  checkIncomingModuleAPI();\n\n  if (Module['arguments']) arguments_ = Module['arguments'];\n  if (Module['thisProgram']) thisProgram = Module['thisProgram'];\n\n  // Assertions on removed incoming Module JS APIs.\n  assert(typeof Module['memoryInitializerPrefixURL'] == 'undefined', 'Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead');\n  assert(typeof Module['pthreadMainPrefixURL'] == 'undefined', 'Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead');\n  assert(typeof Module['cdInitializerPrefixURL'] == 'undefined', 'Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead');\n  assert(typeof Module['filePackagePrefixURL'] == 'undefined', 'Module.filePackagePrefixURL option was removed, use Module.locateFile instead');\n  assert(typeof Module['read'] == 'undefined', 'Module.read option was removed');\n  assert(typeof Module['readAsync'] == 'undefined', 'Module.readAsync option was removed (modify readAsync in JS)');\n  assert(typeof Module['readBinary'] == 'undefined', 'Module.readBinary option was removed (modify readBinary in JS)');\n  assert(typeof Module['setWindowTitle'] == 'undefined', 'Module.setWindowTitle option was removed (modify emscripten_set_window_title in JS)');\n  assert(typeof Module['TOTAL_MEMORY'] == 'undefined', 'Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY');\n  assert(typeof Module['ENVIRONMENT'] == 'undefined', 'Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -sENVIRONMENT=web or -sENVIRONMENT=node)');\n  assert(typeof Module['STACK_SIZE'] == 'undefined', 'STACK_SIZE can no longer be set at runtime.  Use -sSTACK_SIZE at link time')\n  // If memory is defined in wasm, the user can't provide it, or set INITIAL_MEMORY\n  assert(typeof Module['wasmMemory'] == 'undefined', 'Use of `wasmMemory` detected.  Use -sIMPORTED_MEMORY to define wasmMemory externally');\n  assert(typeof Module['INITIAL_MEMORY'] == 'undefined', 'Detected runtime INITIAL_MEMORY setting.  Use -sIMPORTED_MEMORY to define wasmMemory dynamically');\n\n}\n\n// Begin runtime exports\n  var missingLibrarySymbols = [\n  'writeI53ToI64',\n  'writeI53ToI64Clamped',\n  'writeI53ToI64Signaling',\n  'writeI53ToU64Clamped',\n  'writeI53ToU64Signaling',\n  'readI53FromI64',\n  'readI53FromU64',\n  'convertI32PairToI53',\n  'convertI32PairToI53Checked',\n  'convertU32PairToI53',\n  'stackAlloc',\n  'getTempRet0',\n  'setTempRet0',\n  'zeroMemory',\n  'exitJS',\n  'getHeapMax',\n  'growMemory',\n  'withStackSave',\n  'strError',\n  'inetPton4',\n  'inetNtop4',\n  'inetPton6',\n  'inetNtop6',\n  'readSockaddr',\n  'writeSockaddr',\n  'emscriptenLog',\n  'readEmAsmArgs',\n  'jstoi_q',\n  'getExecutableName',\n  'autoResumeAudioContext',\n  'getDynCaller',\n  'dynCall',\n  'handleException',\n  'keepRuntimeAlive',\n  'runtimeKeepalivePush',\n  'runtimeKeepalivePop',\n  'callUserCallback',\n  'maybeExit',\n  'asmjsMangle',\n  'asyncLoad',\n  'alignMemory',\n  'mmapAlloc',\n  'HandleAllocator',\n  'getNativeTypeSize',\n  'getUniqueRunDependency',\n  'addOnInit',\n  'addOnPostCtor',\n  'addOnPreMain',\n  'addOnExit',\n  'STACK_SIZE',\n  'STACK_ALIGN',\n  'POINTER_SIZE',\n  'ASSERTIONS',\n  'ccall',\n  'cwrap',\n  'uleb128Encode',\n  'sigToWasmTypes',\n  'generateFuncType',\n  'convertJsFunctionToWasm',\n  'getEmptyTableSlot',\n  'updateTableMap',\n  'getFunctionAddress',\n  'addFunction',\n  'removeFunction',\n  'reallyNegative',\n  'unSign',\n  'strLen',\n  'reSign',\n  'formatString',\n  'intArrayFromString',\n  'intArrayToString',\n  'stringToAscii',\n  'stringToNewUTF8',\n  'stringToUTF8OnStack',\n  'writeArrayToMemory',\n  'registerKeyEventCallback',\n  'maybeCStringToJsString',\n  'findEventTarget',\n  'getBoundingClientRect',\n  'fillMouseEventData',\n  'registerMouseEventCallback',\n  'registerWheelEventCallback',\n  'registerUiEventCallback',\n  'registerFocusEventCallback',\n  'fillDeviceOrientationEventData',\n  'registerDeviceOrientationEventCallback',\n  'fillDeviceMotionEventData',\n  'registerDeviceMotionEventCallback',\n  'screenOrientation',\n  'fillOrientationChangeEventData',\n  'registerOrientationChangeEventCallback',\n  'fillFullscreenChangeEventData',\n  'registerFullscreenChangeEventCallback',\n  'JSEvents_requestFullscreen',\n  'JSEvents_resizeCanvasForFullscreen',\n  'registerRestoreOldStyle',\n  'hideEverythingExceptGivenElement',\n  'restoreHiddenElements',\n  'setLetterbox',\n  'softFullscreenResizeWebGLRenderTarget',\n  'doRequestFullscreen',\n  'fillPointerlockChangeEventData',\n  'registerPointerlockChangeEventCallback',\n  'registerPointerlockErrorEventCallback',\n  'requestPointerLock',\n  'fillVisibilityChangeEventData',\n  'registerVisibilityChangeEventCallback',\n  'registerTouchEventCallback',\n  'fillGamepadEventData',\n  'registerGamepadEventCallback',\n  'registerBeforeUnloadEventCallback',\n  'fillBatteryEventData',\n  'battery',\n  'registerBatteryEventCallback',\n  'setCanvasElementSize',\n  'getCanvasElementSize',\n  'jsStackTrace',\n  'getCallstack',\n  'convertPCtoSourceLocation',\n  'getEnvStrings',\n  'checkWasiClock',\n  'wasiRightsToMuslOFlags',\n  'wasiOFlagsToMuslOFlags',\n  'initRandomFill',\n  'randomFill',\n  'safeSetTimeout',\n  'setImmediateWrapped',\n  'safeRequestAnimationFrame',\n  'clearImmediateWrapped',\n  'registerPostMainLoop',\n  'registerPreMainLoop',\n  'getPromise',\n  'makePromise',\n  'idsToPromises',\n  'makePromiseCallback',\n  'findMatchingCatch',\n  'Browser_asyncPrepareDataCounter',\n  'isLeapYear',\n  'ydayFromDate',\n  'arraySum',\n  'addDays',\n  'getSocketFromFD',\n  'getSocketAddress',\n  'FS_createPreloadedFile',\n  'FS_modeStringToFlags',\n  'FS_getMode',\n  'FS_stdin_getChar',\n  'FS_mkdirTree',\n  '_setNetworkCallback',\n  'heapObjectForWebGLType',\n  'toTypedArrayIndex',\n  'webgl_enable_ANGLE_instanced_arrays',\n  'webgl_enable_OES_vertex_array_object',\n  'webgl_enable_WEBGL_draw_buffers',\n  'webgl_enable_WEBGL_multi_draw',\n  'webgl_enable_EXT_polygon_offset_clamp',\n  'webgl_enable_EXT_clip_control',\n  'webgl_enable_WEBGL_polygon_mode',\n  'emscriptenWebGLGet',\n  'computeUnpackAlignedImageSize',\n  'colorChannelsInGlTextureFormat',\n  'emscriptenWebGLGetTexPixelData',\n  'emscriptenWebGLGetUniform',\n  'webglGetUniformLocation',\n  'webglPrepareUniformLocationsBeforeFirstUse',\n  'webglGetLeftBracePos',\n  'emscriptenWebGLGetVertexAttrib',\n  '__glGetActiveAttribOrUniform',\n  'writeGLArray',\n  'registerWebGlEventCallback',\n  'runAndAbortIfError',\n  'ALLOC_NORMAL',\n  'ALLOC_STACK',\n  'allocate',\n  'writeStringToMemory',\n  'writeAsciiToMemory',\n  'demangle',\n  'stackTrace',\n  'getFunctionArgsName',\n  'createJsInvokerSignature',\n  'PureVirtualError',\n  'registerInheritedInstance',\n  'unregisterInheritedInstance',\n  'getInheritedInstanceCount',\n  'getLiveInheritedInstances',\n  'enumReadValueFromPointer',\n  'setDelayFunction',\n  'validateThis',\n  'count_emval_handles',\n  'getStringOrSymbol',\n  'emval_get_global',\n  'emval_returnValue',\n  'emval_lookupTypes',\n  'emval_addMethodCaller',\n];\nmissingLibrarySymbols.forEach(missingLibrarySymbol)\n\n  var unexportedSymbols = [\n  'run',\n  'addRunDependency',\n  'removeRunDependency',\n  'out',\n  'err',\n  'callMain',\n  'abort',\n  'wasmMemory',\n  'wasmExports',\n  'HEAPF32',\n  'HEAPF64',\n  'HEAP8',\n  'HEAPU8',\n  'HEAP16',\n  'HEAPU16',\n  'HEAP32',\n  'HEAPU32',\n  'HEAP64',\n  'HEAPU64',\n  'writeStackCookie',\n  'checkStackCookie',\n  'INT53_MAX',\n  'INT53_MIN',\n  'bigintToI53Checked',\n  'stackSave',\n  'stackRestore',\n  'ptrToString',\n  'abortOnCannotGrowMemory',\n  'ENV',\n  'ERRNO_CODES',\n  'DNS',\n  'Protocols',\n  'Sockets',\n  'timers',\n  'warnOnce',\n  'readEmAsmArgsArray',\n  'wasmTable',\n  'noExitRuntime',\n  'addOnPreRun',\n  'addOnPostRun',\n  'freeTableIndexes',\n  'functionsInTableMap',\n  'setValue',\n  'getValue',\n  'PATH',\n  'PATH_FS',\n  'UTF8Decoder',\n  'UTF8ArrayToString',\n  'UTF8ToString',\n  'stringToUTF8Array',\n  'stringToUTF8',\n  'lengthBytesUTF8',\n  'AsciiToString',\n  'UTF16Decoder',\n  'UTF16ToString',\n  'stringToUTF16',\n  'lengthBytesUTF16',\n  'UTF32ToString',\n  'stringToUTF32',\n  'lengthBytesUTF32',\n  'JSEvents',\n  'specialHTMLTargets',\n  'findCanvasEventTarget',\n  'currentFullscreenStrategy',\n  'restoreOldWindowedStyle',\n  'UNWIND_CACHE',\n  'ExitStatus',\n  'flush_NO_FILESYSTEM',\n  'emSetImmediate',\n  'emClearImmediate_deps',\n  'emClearImmediate',\n  'promiseMap',\n  'uncaughtExceptionCount',\n  'exceptionLast',\n  'exceptionCaught',\n  'ExceptionInfo',\n  'Browser',\n  'requestFullscreen',\n  'requestFullScreen',\n  'setCanvasSize',\n  'getUserMedia',\n  'createContext',\n  'getPreloadedImageData__data',\n  'wget',\n  'MONTH_DAYS_REGULAR',\n  'MONTH_DAYS_LEAP',\n  'MONTH_DAYS_REGULAR_CUMULATIVE',\n  'MONTH_DAYS_LEAP_CUMULATIVE',\n  'SYSCALLS',\n  'preloadPlugins',\n  'FS_stdin_getChar_buffer',\n  'FS_unlink',\n  'FS_createPath',\n  'FS_createDevice',\n  'FS_readFile',\n  'FS',\n  'FS_root',\n  'FS_mounts',\n  'FS_devices',\n  'FS_streams',\n  'FS_nextInode',\n  'FS_nameTable',\n  'FS_currentPath',\n  'FS_initialized',\n  'FS_ignorePermissions',\n  'FS_filesystems',\n  'FS_syncFSRequests',\n  'FS_readFiles',\n  'FS_lookupPath',\n  'FS_getPath',\n  'FS_hashName',\n  'FS_hashAddNode',\n  'FS_hashRemoveNode',\n  'FS_lookupNode',\n  'FS_createNode',\n  'FS_destroyNode',\n  'FS_isRoot',\n  'FS_isMountpoint',\n  'FS_isFile',\n  'FS_isDir',\n  'FS_isLink',\n  'FS_isChrdev',\n  'FS_isBlkdev',\n  'FS_isFIFO',\n  'FS_isSocket',\n  'FS_flagsToPermissionString',\n  'FS_nodePermissions',\n  'FS_mayLookup',\n  'FS_mayCreate',\n  'FS_mayDelete',\n  'FS_mayOpen',\n  'FS_checkOpExists',\n  'FS_nextfd',\n  'FS_getStreamChecked',\n  'FS_getStream',\n  'FS_createStream',\n  'FS_closeStream',\n  'FS_dupStream',\n  'FS_doSetAttr',\n  'FS_chrdev_stream_ops',\n  'FS_major',\n  'FS_minor',\n  'FS_makedev',\n  'FS_registerDevice',\n  'FS_getDevice',\n  'FS_getMounts',\n  'FS_syncfs',\n  'FS_mount',\n  'FS_unmount',\n  'FS_lookup',\n  'FS_mknod',\n  'FS_statfs',\n  'FS_statfsStream',\n  'FS_statfsNode',\n  'FS_create',\n  'FS_mkdir',\n  'FS_mkdev',\n  'FS_symlink',\n  'FS_rename',\n  'FS_rmdir',\n  'FS_readdir',\n  'FS_readlink',\n  'FS_stat',\n  'FS_fstat',\n  'FS_lstat',\n  'FS_doChmod',\n  'FS_chmod',\n  'FS_lchmod',\n  'FS_fchmod',\n  'FS_doChown',\n  'FS_chown',\n  'FS_lchown',\n  'FS_fchown',\n  'FS_doTruncate',\n  'FS_truncate',\n  'FS_ftruncate',\n  'FS_utime',\n  'FS_open',\n  'FS_close',\n  'FS_isClosed',\n  'FS_llseek',\n  'FS_read',\n  'FS_write',\n  'FS_mmap',\n  'FS_msync',\n  'FS_ioctl',\n  'FS_writeFile',\n  'FS_cwd',\n  'FS_chdir',\n  'FS_createDefaultDirectories',\n  'FS_createDefaultDevices',\n  'FS_createSpecialDirectories',\n  'FS_createStandardStreams',\n  'FS_staticInit',\n  'FS_init',\n  'FS_quit',\n  'FS_findObject',\n  'FS_analyzePath',\n  'FS_createFile',\n  'FS_createDataFile',\n  'FS_forceLoadFile',\n  'FS_createLazyFile',\n  'FS_absolutePath',\n  'FS_createFolder',\n  'FS_createLink',\n  'FS_joinPath',\n  'FS_mmapAlloc',\n  'FS_standardizePath',\n  'MEMFS',\n  'TTY',\n  'PIPEFS',\n  'SOCKFS',\n  'tempFixedLengthArray',\n  'miniTempWebGLFloatBuffers',\n  'miniTempWebGLIntBuffers',\n  'GL',\n  'AL',\n  'GLUT',\n  'EGL',\n  'GLEW',\n  'IDBStore',\n  'SDL',\n  'SDL_gfx',\n  'allocateUTF8',\n  'allocateUTF8OnStack',\n  'print',\n  'printErr',\n  'jstoi_s',\n  'InternalError',\n  'BindingError',\n  'throwInternalError',\n  'throwBindingError',\n  'registeredTypes',\n  'awaitingDependencies',\n  'typeDependencies',\n  'tupleRegistrations',\n  'structRegistrations',\n  'sharedRegisterType',\n  'whenDependentTypesAreResolved',\n  'getTypeName',\n  'getFunctionName',\n  'heap32VectorToArray',\n  'requireRegisteredType',\n  'usesDestructorStack',\n  'checkArgCount',\n  'getRequiredArgCount',\n  'createJsInvoker',\n  'UnboundTypeError',\n  'GenericWireTypeSize',\n  'EmValType',\n  'EmValOptionalType',\n  'throwUnboundTypeError',\n  'ensureOverloadTable',\n  'exposePublicSymbol',\n  'replacePublicSymbol',\n  'createNamedFunction',\n  'embindRepr',\n  'registeredInstances',\n  'getBasestPointer',\n  'getInheritedInstance',\n  'registeredPointers',\n  'registerType',\n  'integerReadValueFromPointer',\n  'floatReadValueFromPointer',\n  'assertIntegerRange',\n  'readPointer',\n  'runDestructors',\n  'craftInvokerFunction',\n  'embind__requireFunction',\n  'genericPointerToWireType',\n  'constNoSmartPtrRawPointerToWireType',\n  'nonConstNoSmartPtrRawPointerToWireType',\n  'init_RegisteredPointer',\n  'RegisteredPointer',\n  'RegisteredPointer_fromWireType',\n  'runDestructor',\n  'releaseClassHandle',\n  'finalizationRegistry',\n  'detachFinalizer_deps',\n  'detachFinalizer',\n  'attachFinalizer',\n  'makeClassHandle',\n  'init_ClassHandle',\n  'ClassHandle',\n  'throwInstanceAlreadyDeleted',\n  'deletionQueue',\n  'flushPendingDeletes',\n  'delayFunction',\n  'RegisteredClass',\n  'shallowCopyInternalPointer',\n  'downcastPointer',\n  'upcastPointer',\n  'char_0',\n  'char_9',\n  'makeLegalFunctionName',\n  'emval_freelist',\n  'emval_handles',\n  'emval_symbols',\n  'Emval',\n  'emval_methodCallers',\n];\nunexportedSymbols.forEach(unexportedRuntimeSymbol);\n\n  // End runtime exports\n  // Begin JS library exports\n  // End JS library exports\n\n// end include: postlibrary.js\n\nfunction checkIncomingModuleAPI() {\n  ignoredModuleProp('fetchSettings');\n}\n\n// Imports from the Wasm binary.\nvar ___getTypeName = makeInvalidEarlyAccess('___getTypeName');\nvar _fflush = makeInvalidEarlyAccess('_fflush');\nvar _emscripten_stack_get_end = makeInvalidEarlyAccess('_emscripten_stack_get_end');\nvar _emscripten_stack_get_base = makeInvalidEarlyAccess('_emscripten_stack_get_base');\nvar _malloc = makeInvalidEarlyAccess('_malloc');\nvar _strerror = makeInvalidEarlyAccess('_strerror');\nvar _free = makeInvalidEarlyAccess('_free');\nvar _emscripten_stack_init = makeInvalidEarlyAccess('_emscripten_stack_init');\nvar _emscripten_stack_get_free = makeInvalidEarlyAccess('_emscripten_stack_get_free');\nvar __emscripten_stack_restore = makeInvalidEarlyAccess('__emscripten_stack_restore');\nvar __emscripten_stack_alloc = makeInvalidEarlyAccess('__emscripten_stack_alloc');\nvar _emscripten_stack_get_current = makeInvalidEarlyAccess('_emscripten_stack_get_current');\n\nfunction assignWasmExports(wasmExports) {\n  ___getTypeName = createExportWrapper('__getTypeName', 1);\n  _fflush = createExportWrapper('fflush', 1);\n  _emscripten_stack_get_end = wasmExports['emscripten_stack_get_end'];\n  _emscripten_stack_get_base = wasmExports['emscripten_stack_get_base'];\n  _malloc = createExportWrapper('malloc', 1);\n  _strerror = createExportWrapper('strerror', 1);\n  _free = createExportWrapper('free', 1);\n  _emscripten_stack_init = wasmExports['emscripten_stack_init'];\n  _emscripten_stack_get_free = wasmExports['emscripten_stack_get_free'];\n  __emscripten_stack_restore = wasmExports['_emscripten_stack_restore'];\n  __emscripten_stack_alloc = wasmExports['_emscripten_stack_alloc'];\n  _emscripten_stack_get_current = wasmExports['emscripten_stack_get_current'];\n}\nvar wasmImports = {\n  /** @export */\n  __cxa_throw: ___cxa_throw,\n  /** @export */\n  _abort_js: __abort_js,\n  /** @export */\n  _embind_register_bigint: __embind_register_bigint,\n  /** @export */\n  _embind_register_bool: __embind_register_bool,\n  /** @export */\n  _embind_register_class: __embind_register_class,\n  /** @export */\n  _embind_register_class_constructor: __embind_register_class_constructor,\n  /** @export */\n  _embind_register_class_function: __embind_register_class_function,\n  /** @export */\n  _embind_register_emval: __embind_register_emval,\n  /** @export */\n  _embind_register_float: __embind_register_float,\n  /** @export */\n  _embind_register_function: __embind_register_function,\n  /** @export */\n  _embind_register_integer: __embind_register_integer,\n  /** @export */\n  _embind_register_memory_view: __embind_register_memory_view,\n  /** @export */\n  _embind_register_optional: __embind_register_optional,\n  /** @export */\n  _embind_register_std_string: __embind_register_std_string,\n  /** @export */\n  _embind_register_std_wstring: __embind_register_std_wstring,\n  /** @export */\n  _embind_register_void: __embind_register_void,\n  /** @export */\n  _emval_decref: __emval_decref,\n  /** @export */\n  _emval_take_value: __emval_take_value,\n  /** @export */\n  emscripten_resize_heap: _emscripten_resize_heap,\n  /** @export */\n  fd_close: _fd_close,\n  /** @export */\n  fd_seek: _fd_seek,\n  /** @export */\n  fd_write: _fd_write\n};\nvar wasmExports = await createWasm();\n\n\n// include: postamble.js\n// === Auto-generated postamble setup entry stuff ===\n\nvar calledRun;\n\nfunction stackCheckInit() {\n  // This is normally called automatically during __wasm_call_ctors but need to\n  // get these values before even running any of the ctors so we call it redundantly\n  // here.\n  _emscripten_stack_init();\n  // TODO(sbc): Move writeStackCookie to native to to avoid this.\n  writeStackCookie();\n}\n\nfunction run() {\n\n  if (runDependencies > 0) {\n    dependenciesFulfilled = run;\n    return;\n  }\n\n  stackCheckInit();\n\n  preRun();\n\n  // a preRun added a dependency, run will be called later\n  if (runDependencies > 0) {\n    dependenciesFulfilled = run;\n    return;\n  }\n\n  function doRun() {\n    // run may have just been called through dependencies being fulfilled just in this very frame,\n    // or while the async setStatus time below was happening\n    assert(!calledRun);\n    calledRun = true;\n    Module['calledRun'] = true;\n\n    if (ABORT) return;\n\n    initRuntime();\n\n    readyPromiseResolve?.(Module);\n    Module['onRuntimeInitialized']?.();\n    consumedModuleProp('onRuntimeInitialized');\n\n    assert(!Module['_main'], 'compiled without a main, but one is present. if you added it from JS, use Module[\"onRuntimeInitialized\"]');\n\n    postRun();\n  }\n\n  if (Module['setStatus']) {\n    Module['setStatus']('Running...');\n    setTimeout(() => {\n      setTimeout(() => Module['setStatus'](''), 1);\n      doRun();\n    }, 1);\n  } else\n  {\n    doRun();\n  }\n  checkStackCookie();\n}\n\nfunction checkUnflushedContent() {\n  // Compiler settings do not allow exiting the runtime, so flushing\n  // the streams is not possible. but in ASSERTIONS mode we check\n  // if there was something to flush, and if so tell the user they\n  // should request that the runtime be exitable.\n  // Normally we would not even include flush() at all, but in ASSERTIONS\n  // builds we do so just for this check, and here we see if there is any\n  // content to flush, that is, we check if there would have been\n  // something a non-ASSERTIONS build would have not seen.\n  // How we flush the streams depends on whether we are in SYSCALLS_REQUIRE_FILESYSTEM=0\n  // mode (which has its own special function for this; otherwise, all\n  // the code is inside libc)\n  var oldOut = out;\n  var oldErr = err;\n  var has = false;\n  out = err = (x) => {\n    has = true;\n  }\n  try { // it doesn't matter if it fails\n    flush_NO_FILESYSTEM();\n  } catch(e) {}\n  out = oldOut;\n  err = oldErr;\n  if (has) {\n    warnOnce('stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the Emscripten FAQ), or make sure to emit a newline when you printf etc.');\n    warnOnce('(this may also be due to not including full filesystem support - try building with -sFORCE_FILESYSTEM)');\n  }\n}\n\nfunction preInit() {\n  if (Module['preInit']) {\n    if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];\n    while (Module['preInit'].length > 0) {\n      Module['preInit'].shift()();\n    }\n  }\n  consumedModuleProp('preInit');\n}\n\npreInit();\nrun();\n\n// end include: postamble.js\n\n// include: postamble_modularize.js\n// In MODULARIZE mode we wrap the generated code in a factory function\n// and return either the Module itself, or a promise of the module.\n//\n// We assign to the `moduleRtn` global here and configure closure to see\n// this as and extern so it won't get minified.\n\nif (runtimeInitialized)  {\n  moduleRtn = Module;\n} else {\n  // Set up the promise that indicates the Module is initialized\n  moduleRtn = new Promise((resolve, reject) => {\n    readyPromiseResolve = resolve;\n    readyPromiseReject = reject;\n  });\n}\n\n// Assertion for attempting to access module properties on the incoming\n// moduleArg.  In the past we used this object as the prototype of the module\n// and assigned properties to it, but now we return a distinct object.  This\n// keeps the instance private until it is ready (i.e the promise has been\n// resolved).\nfor (const prop of Object.keys(Module)) {\n  if (!(prop in moduleArg)) {\n    Object.defineProperty(moduleArg, prop, {\n      configurable: true,\n      get() {\n        abort(`Access to module property ('${prop}') is no longer possible via the module constructor argument; Instead, use the result of the module constructor.`)\n      }\n    });\n  }\n}\n// end include: postamble_modularize.js\n\n\n\n  return moduleRtn;\n}\n);\n})();\nif (typeof exports === 'object' && typeof module === 'object') {\n  module.exports = createModule;\n  // This default export looks redundant, but it allows TS to import this\n  // commonjs style module.\n  module.exports.default = createModule;\n} else if (typeof define === 'function' && define['amd'])\n  define([], () => createModule);\n"],"names":["$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","a","$fe67dcd16bfc3fb2$var$modulePromise","__esModule","default","$fe67dcd16bfc3fb2$var$optimize","config","serialized","Module","optimize","groups","people","length","roles","tables","weeks","result","person","group","role","table","week","offset","get","roleRaw","push","self","postMessage","operation","payload","onmessage","e","data","_scriptName","$60a79d9be2fe59af$var$createModule","document","currentScript","src","undefined","moduleArg","prop","moduleRtn","readAsync","readBinary","wasmBinary","readyPromiseResolve","readyPromiseReject","wasmMemory","HEAP8","HEAPU8","HEAP16","HEAPU16","HEAP32","HEAPU32","HEAPF32","HEAPF64","HEAP64","HEAPU64","wasmBinaryFile","delayFunction","wasmTable","calledRun","scriptDirectory","URL","href","window","WorkerGlobalScope","url","assert","isFileURI","response","fetch","credentials","ok","arrayBuffer","status","out","console","log","bind","error","WebAssembly","ABORT","condition","text","abort","filename","startsWith","checkStackCookie","max","_emscripten_stack_get_end","cookie1","cookie2","ptrToString","h16","Int16Array","h8","Int8Array","buffer","consumedModuleProp","Object","getOwnPropertyDescriptor","defineProperty","configurable","set","makeInvalidEarlyAccess","name","unexportedRuntimeSymbol","sym","msg","isExportedByForceFilesystem","runtimeInitialized","Int32Array","Float64Array","prototype","subarray","runDependencies","dependenciesFulfilled","runDependencyTracking","runDependencyWatcher","what","RuntimeError","FS","createDataFile","createPreloadedFile","createLazyFile","open","mkdev","registerDevice","analyzePath","ErrnoError","createExportWrapper","nargs","args","f","wasmExports","getWasmBinary","binaryFile","Uint8Array","file","instantiateArrayBuffer","imports","binary","instantiate","reason","instantiateAsync","instantiateStreaming","createWasm","receiveInstance","instance","module1","b","Uint16Array","Uint32Array","Float32Array","BigInt64Array","BigUint64Array","___getTypeName","_malloc","_free","_emscripten_stack_init","clearInterval","callback","setInterval","shown","dep","path","trueModule","info","wasmImports","Promise","resolve","reject","mod","inst","callRuntimeCallbacks","callbacks","shift","onPostRuns","addOnPostRun","cb","onPreRuns","addOnPreRun","ptr","toString","padStart","warnOnce","ExceptionInfo","excPtr","set_type","type","get_type","set_destructor","destructor","get_destructor","set_caught","caught","get_caught","set_rethrown","rethrown","get_rethrown","set_adjusted_ptr","adjustedPtr","get_adjusted_ptr","uncaughtExceptionCount","AsciiToString","str","ch","String","fromCharCode","awaitingDependencies","registeredTypes","typeDependencies","BindingError","message","throwBindingError","registerType","rawType","registeredInstance","options","argPackAdvance","TypeError","sharedRegisterType","hasOwnProperty","ignoreDuplicateRegistrations","forEach","integerReadValueFromPointer","width","signed","pointer","embindRepr","v","t","assertIntegerRange","typeName","value","minRange","maxRange","throwInstanceAlreadyDeleted","obj","getInstanceTypeName","handle","$$","ptrType","registeredClass","finalizationRegistry","detachFinalizer","releaseClassHandle","count","toDelete","smartPtr","smartPtrType","rawDestructor","downcastPointer","ptrClass","desiredClass","baseClass","rv","downcast","registeredPointers","registeredInstances","InternalError","throwInternalError","makeClassHandle","record","hasSmartPtrType","attachFinalizer","create","writable","RegisteredPointer_fromWireType","toType","rawPointer","getPointee","getBasestPointer","class_","upcast","makeDefaultHandle","isSmartPointer","instancePrototype","pointeeType","registeredPointerRecord","getActualType","isConst","constPointerType","pointerType","dp","FinalizationRegistry","warn","leakWarning","cls","captureStackTrace","stack","replace","unregister","deletionQueue","flushPendingDeletes","pop","deleteScheduled","ClassHandle","createNamedFunction","func","ensureOverloadTable","proto","methodName","humanName","overloadTable","prevFunc","apply","argCount","exposePublicSymbol","numArguments","RegisteredClass","constructor","pureVirtualFunctions","upcastPointer","constNoSmartPtrRawPointerToWireType","destructors","isReference","handleClass","genericPointerToWireType","rawConstructor","sharingPolicy","clonedHandle","rawShare","Emval","toHandle","nonConstNoSmartPtrRawPointerToWireType","readPointer","RegisteredPointer","rawGetPointee","destructorFunction","replacePublicSymbol","wasmTableMirror","embind__requireFunction","signature","rawFunction","isAsync","fp","UnboundTypeError","getTypeName","throwUnboundTypeError","types","unboundTypes","seen","visit","map","join","whenDependentTypesAreResolved","myTypes","dependentTypes","getTypeConverters","onComplete","typeConverters","myTypeConverters","i","Array","unregisteredTypes","registered","dt","heap32VectorToArray","firstElement","array","runDestructors","del","usesDestructorStack","argTypes","checkArgCount","numArgs","minArgs","maxArgs","argCountMessage","craftInvokerFunction","classType","cppInvokerFunc","cppTargetFunc","isClassMethodFunc","needsDestructorStack","returns","getRequiredArgCount","requiredArgCount","optional","closureArgs","invokerFnBody","createJsInvoker","argsList","argsListWired","dtorStack","args1","paramName","Function","getFunctionName","argsIndex","trim","indexOf","endsWith","slice","emval_freelist","emval_handles","__emval_decref","toValue","EmValType","EmValOptionalType","assign","UTF8Decoder","TextDecoder","UTF8ArrayToString","heapOrArray","idx","maxBytesToRead","NaN","endIdx","endPtr","decode","u0","u1","u2","UTF8ToString","UTF16Decoder","UTF16ToString","maxIdx","codeUnit","stringToUTF16","outPtr","maxBytesToWrite","startPtr","numCharsToWrite","charCodeAt","lengthBytesUTF16","UTF32ToString","utf32","fromCodePoint","stringToUTF32","codePoint","codePointAt","lengthBytesUTF32","len","printCharBuffers","printChar","stream","curr","other","leftClass","left","rightClass","right","preservePointerOnDelete","o","clone","getPrototypeOf","symbolDispose","Symbol","dispose","missingLibrarySymbols","unexportedSymbols","__cxa_throw","_abort_js","_embind_register_bigint","primitiveType","size","isUnsignedType","fromWireType","bitSize","BigInt","asUintN","_embind_register_bool","trueValue","falseValue","wt","_embind_register_class","rawPointerType","rawConstPointerType","baseClassRawType","getActualTypeSignature","upcastSignature","downcastSignature","destructorSignature","legalFunctionName","base","basePrototype","constructor_body","body","keys","__derivedClasses","referenceConverter","pointerConverter","constPointerConverter","_embind_register_class_constructor","rawClassType","rawArgTypesAddr","invokerSignature","invoker","rawArgTypes","splice","_embind_register_class_function","rawInvoker","context","isPureVirtual","isNonnullReturn","unboundTypesHandler","substring","method","className","memberFunction","_embind_register_emval","_embind_register_float","floatReadValueFromPointer","_embind_register_function","fn","invokerArgsArray","concat","_embind_register_integer","bitshift","_embind_register_memory_view","dataTypeIndex","TA","typeMapping","decodeMemoryView","_embind_register_optional","rawOptionalType","_embind_register_std_string","decodeStartPtr","currentBytePtr","maxRead","stringSegment","ArrayBuffer","valueIsOfTypeString","isView","BYTES_PER_ELEMENT","lengthBytesUTF8","c","charCode","stringToUTF8","heap","outIdx","u","_embind_register_std_wstring","charSize","decodeString","encodeString","readCharAt","lengthBytesUTF","maxReadBytes","_embind_register_void","isVoid","_emval_decref","_emval_take_value","arg","impl","emscripten_resize_heap","requestedSize","fd_close","fd","fd_seek","whence","newOffset","num","Number","fd_write","iov","iovcnt","pnum","j","run","doRun","setTimeout"],"version":3,"file":"wasm-worker.2ad872a2.js.map"}